<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--
    This file implements an interactive Aspirational Identity Map (AIM) as a three‑ring
    sunburst diagram.  The specification for this visualization is defined in the
    accompanying product spec.  The implementation uses D3.js for drawing arcs
    and handling user interactions.  See the accompanying JavaScript code at
    the bottom of this file for details.  The colour palette and ring sizing
    originate from the specification, while the layout adapts responsively
    to smaller screens.  All strings, labels and beliefs are driven by a
    CSV file (examples/aim.csv by default) that can be replaced at runtime
    via the “Load CSV” button.
  -->
  <title>AIM (Aspirational Identity Map)</title>
  <style>
    /* Basic reset and typography */
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #ffffff;
      color: #333333;
    }
    #titleBar {
      font-size: 1.4rem;
      font-weight: 600;
      padding: 16px;
      border-bottom: 1px solid #e0e0e0;
    }
    /* Container flex layout */
    #container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
      padding: 12px;
      gap: 16px;
    }
    /* Chart wrapper grows to fill space */
    #chartWrapper {
      /* Allow the chart wrapper to take up all available horizontal space */
      flex: 1 1 0;
      min-width: 0;
      position: relative;
      /* Reserve vertical space so the chart isn’t constrained to a tiny area. The
         height will be further constrained by computeRadii() to fit within
         the viewport on desktop. */
      min-height: 480px;
    }
    svg#aimChart {
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Sidebar/legend area */
    #sidebar {
      width: 220px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }
    button {
      padding: 6px 10px;
      font-size: 0.9rem;
      cursor: pointer;
      border: 1px solid #cccccc;
      border-radius: 4px;
      background: #f5f5f5;
    }
    button:hover {
      background: #eaeaea;
    }
    #legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .legend-chip {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      position: relative;
    }
    .legend-chip .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
      flex-shrink: 0;
    }
    .legend-chip:hover .dot,
    .legend-chip:focus-visible .dot {
      outline: 2px solid currentColor;
    }
    .legend-chip.selected .dot {
      border: 2px solid currentColor;
    }
    /* Tooltip styles */
    #tooltip {
      position: fixed;
      pointer-events: none;
      background: #ffffff;
      border-radius: 4px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.12), 0 2px 8px rgba(0,0,0,0.08);
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.3;
      z-index: 200;
      max-width: 240px;
      display: none;
      color: #111;
    }
    #tooltip .breadcrumb {
      font-size: 11px;
      color: #666;
      margin-top: 2px;
    }
    /* Overlay for the table view */
    #tableOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }
    #tableOverlay .tableContainer {
      background: #ffffff;
      border-radius: 6px;
      max-width: 90%;
      max-height: 90%;
      padding: 16px;
      overflow: auto;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }
    #tableOverlay table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    #tableOverlay th, #tableOverlay td {
      border: 1px solid #dddddd;
      padding: 6px 8px;
      vertical-align: top;
    }
    #tableOverlay th {
      background: #f5f5f5;
      font-weight: 600;
    }
    #tableOverlay tbody tr:nth-child(even) {
      background: #fcfcfc;
    }
    #tableOverlay input[type="search"] {
      width: 100%;
      padding: 6px;
      margin-bottom: 10px;
      border: 1px solid #cccccc;
      border-radius: 4px;
    }
    #closeTableBtn {
      margin-bottom: 8px;
    }
    /* Responsive adjustments */
    @media (max-width: 600px) {
      #container {
        flex-direction: column;
      }
      #sidebar {
        width: auto;
        margin-top: 20px;
      }
      #legend {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 12px;
      }
    }
    /* Focus ring for SVG arcs */
    .wedge:focus-visible {
      stroke: #000;
      stroke-width: 2px;
    }

    /* Remove default focus outline on SVG paths to avoid blue focus rectangles */
    svg .wedge:focus {
      outline: none;
    }
  </style>
</head>
<body>
  <header id="titleBar">AIM</header>
  <div id="container">
    <div id="chartWrapper">
      <!-- Chart SVG will be inserted here -->
      <svg id="aimChart" role="img" aria-label="Aspirational Identity Map"></svg>
    </div>
    <div id="sidebar">
      <button id="resetBtn" aria-label="Reset the map to global view">Reset</button>
      <div id="legend" aria-label="Pillar legend"></div>

      <!-- Toggle to switch confidence heatmap on/off -->
      <div id="confidenceToggleContainer" style="font-size:0.85rem; display:flex; align-items:center; cursor:pointer; gap:4px;">
        <input type="checkbox" id="confidenceToggle" aria-label="Toggle confidence heatmap">
        <span>Show confidence heatmap</span>
      </div>

      <!-- Button to open the data management overlay -->
      <button id="viewTableBtn" aria-label="Edit data">Edit data</button>

      <!-- Lenses block -->
      <div id="lensesBlock" style="margin-top:12px; max-width:200px;" aria-label="Lenses section">
        <div style="font-weight:600; margin-bottom:4px;">Lenses</div>
        <div id="lensesList" style="font-size:0.85rem; color:#333;">No lenses</div>
      </div>
      <input type="file" id="csvFileInput" accept=".csv" style="display:none" aria-label="CSV file input">
      <!-- Remove download example link since export is available in table view -->
    </div>
  </div>
  <div id="tooltip" role="tooltip" aria-hidden="true"></div>
  <div id="tableOverlay" role="dialog" aria-modal="true" aria-label="AIM table view">
    <div class="tableContainer">
      <button id="closeTableBtn" aria-label="Close table view">Close</button>
      <!-- Editable title for the AIM map -->
      <div style="margin: 6px 0; display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
        <label for="editTitleInput" style="font-size:0.85rem;">Name:</label>
        <input type="text" id="editTitleInput" placeholder="Enter map name" style="flex:1; min-width:150px; padding:4px; font-size:0.85rem; border:1px solid #ccc; border-radius:4px;">
        <button id="downloadCsvBtn" aria-label="Download CSV" style="padding:6px 10px; font-size:0.85rem;">Download CSV</button>
        <button id="uploadCsvBtn" aria-label="Upload CSV" style="padding:6px 10px; font-size:0.85rem;">Upload CSV</button>
      </div>
      <input type="search" id="tableSearch" placeholder="Search belief…" aria-label="Search beliefs">
      <table id="nodeTable">
        <thead>
          <tr><th>Depth</th><th>Pillar</th><th>Sub</th><th>Micro</th><th>Label</th><th>Belief</th><th>Confidence</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <!-- D3 library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  // Wrap all variables inside an IIFE to avoid polluting the global scope
  (function() {
    // Character limits for truncating belief text by depth.  These values
    // determine how many characters are kept before adding an ellipsis.  We
    // deliberately allow more characters than before so truncated labels are
    // longer but still fit within their wedges.  Depth 1 (pillars) has the
    // highest allowance, depth 2 (subs) is moderate, and depth 3 (micros) is
    // shorter.  Centre/pillar/sub beliefs use a separate limit below.
    // Maximum number of characters to display in labels for each depth.  These
    // values are intentionally conservative to reduce overflow: depth 1 (pillars)
    // gets 45 characters, depth 2 (subs) gets 35 and depth 3 (micros) gets 25.
    const maxCharsByDepth = {1: 45, 2: 35, 3: 25};

    // Maximum characters for centre and legend beliefs.  These apply when
    // displaying the belief in the centre of the chart or the outer ring of
    // three (pillars, subs or micros).  Truncating with an ellipsis keeps
    // the visible text concise; hovering reveals the full belief via tooltip.
    // Maximum characters allowed in the centre belief (core/pillar/sub).  A
    // lower limit reduces overflow in the core view.  Full text remains
    // accessible via the tooltip.
    const centerMaxChars = 70;
    // Base RGB colours for the three pillars
    const pillarBases = [
      [42, 161, 152],    // teal
      [94, 92, 230],     // indigo/lavender
      [255, 138, 61]     // orange
    ];
    // Alpha values by depth (1: pillars, 2: subs, 3: micros)
    const depthAlpha = {1: 0.25, 2: 0.20, 3: 0.18};
    // Data model for the current AIM dataset
    let aimData = null;
    // Current visual state: 'A' (global), 'B' (pillar focus), 'C' (sub focus)
    let currentState = 'A';
    let selectedPillar = null;   // integer 1..3 when in B or C
    let selectedSub = null;      // integer 1..3 when in C
    let preselectedSub = null;   // used when entering B from a sub click

    // Whether to display the confidence heatmap overlay.  When set to true
    // the base pillar colours are blended with a hue based on each belief’s
    // confidence (0–100).  This is controlled via the "Show confidence
    // heatmap" checkbox in the sidebar.
    let showConfidence = false;

    /**
     * Blending coefficient for the confidence heatmap.  When the heatmap is
     * enabled, the pillar’s base colour is blended with a heat colour
     * representing the confidence value.  A higher coefficient emphasises
     * differences in confidence.  We set this to 1.0 (100% heat) so
     * confidence values dominate the colour and remain visible.
     */
    const heatBlendRatio = 1.0;

    /**
     * Computes a heat colour from a confidence value in the range 0–100.
     * The hue transitions linearly from red (low confidence) at 0° through
     * yellow at 60° to green at 120°.  Saturation and lightness are fixed
     * to preserve contrast with the base palette.  Returns an array of
     * [r,g,b] values on a 0–255 scale.
     *
     * @param {number} conf Confidence value (0–100)
     * @returns {number[]} Array [r,g,b] colour components
     */
    function computeHeatColor(conf) {
      const ratio = Math.max(0, Math.min(100, conf)) / 100;
      const hue = 120 * ratio; // 0 (red) to 120 (green)
      // Increase saturation and slightly darken the heat colour so that
      // confidence differences are more pronounced on a white background.  A
      // saturation of 0.65 and lightness of 0.45 produce deeper reds and greens.
      const hslColor = d3.hsl(hue, 0.65, 0.45);
      const rgb = hslColor.rgb();
      return [Math.round(rgb.r), Math.round(rgb.g), Math.round(rgb.b)];
    }

    /**
     * Determines the fill colour for a wedge descriptor.  When the
     * confidence heatmap is disabled, this simply applies the pillar’s base
     * RGB with a depth‑specific alpha.  When enabled, the base colour is
     * blended 50/50 with a heat colour derived from the belief’s
     * confidence value.  The alpha remains tied to the depth as per the
     * original specification.
     *
     * @param {Object} descriptor The wedge descriptor containing pillar,
     *     depth and confidence properties
     * @returns {string} CSS rgba colour string
     */
    function computeFillColor(descriptor) {
      const base = pillarBases[descriptor.pillar - 1];
      const alpha = depthAlpha[descriptor.depth];
      if (!showConfidence) {
        return `rgba(${base[0]},${base[1]},${base[2]},${alpha})`;
      }
      // Use pure heat colour when the confidence heatmap is enabled.  The
      // ratio is set to 1.0, so no blending with the base colour occurs.  This
      // produces a clear red‑to‑green gradient independent of the pillar.
      const heat = computeHeatColor(descriptor.confidence || 50);
      const r = heat[0];
      const g = heat[1];
      const b = heat[2];
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // Cached DOM selections
    const svg = d3.select('#aimChart');
    const tooltip = d3.select('#tooltip');
    const legendContainer = d3.select('#legend');
    const titleBar = d3.select('#titleBar');

    // Setup file input for CSV loading
    const fileInput = document.getElementById('csvFileInput');
    // Bind upload CSV button (inside the table overlay) to trigger the hidden file input
    const uploadCsvBtn = document.getElementById('uploadCsvBtn');
    if (uploadCsvBtn) {
      uploadCsvBtn.addEventListener('click', () => {
        if (fileInput) fileInput.click();
      });
    }
    if (fileInput) {
      fileInput.addEventListener('change', handleFileUpload);
    }

    // Reset button
    document.getElementById('resetBtn').addEventListener('click', () => {
      // Reset visual state
      currentState = 'A';
      selectedPillar = null;
      selectedSub = null;
      preselectedSub = null;
      // Disable confidence heatmap
      showConfidence = false;
      // Uncheck the confidence toggle UI if present
      if (confidenceToggle) confidenceToggle.checked = false;
      // Redraw chart, legend and lenses
      updateChart();
      updateLegend();
      updateLenses();
    });

    // Table view controls
    const tableOverlay = document.getElementById('tableOverlay');
    const tableBody = document.querySelector('#nodeTable tbody');
    const closeTableBtn = document.getElementById('closeTableBtn');
    const viewTableBtn = document.getElementById('viewTableBtn');
    const tableSearchInput = document.getElementById('tableSearch');
    const editTitleInput = document.getElementById('editTitleInput');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');

    // Confidence heatmap toggle
    const confidenceToggle = document.getElementById('confidenceToggle');
    if (confidenceToggle) {
      confidenceToggle.addEventListener('change', () => {
        showConfidence = confidenceToggle.checked;
        updateChart();
        // Also update lenses colour when confidence toggled
        updateLenses();
      });
    }

    viewTableBtn.addEventListener('click', () => {
      buildTableView();
      tableOverlay.style.display = 'flex';
      tableSearchInput.value = '';
      filterTable('');
      // Populate the editable title input with current map name
      if (editTitleInput) {
        editTitleInput.value = aimData && aimData.title ? aimData.title : '';
      }
    });
    closeTableBtn.addEventListener('click', () => {
      tableOverlay.style.display = 'none';
    });
    tableSearchInput.addEventListener('input', () => {
      filterTable(tableSearchInput.value.trim().toLowerCase());
    });

    // Update the map title when edited in the table overlay
    if (editTitleInput) {
      editTitleInput.addEventListener('input', () => {
        if (!aimData) return;
        aimData.title = editTitleInput.value.trim();
        // Update page title bar and document title
        const name = aimData.title || '';
        let pageTitle;
        if (name) {
          pageTitle = `AIM (Aspirational Identity Map): ${name}`;
        } else {
          const modeLabel = aimData.mode === 'personal' ? 'Personal' : 'Business';
          pageTitle = `AIM (Aspirational Identity Map): ${modeLabel}`;
        }
        document.title = pageTitle;
        titleBar.text(pageTitle);
      });
    }

    // Download the current AIM data as a CSV file
    if (downloadCsvBtn) {
      downloadCsvBtn.addEventListener('click', () => {
        if (!aimData) return;
        const rows = [];
        // Meta rows (no confidence values)
        rows.push({ label: 'title', belief: aimData.title || '', confidence: '' });
        rows.push({ label: 'mode', belief: aimData.mode || '', confidence: '' });
        // Pillar names (no confidence values)
        for (let i = 1; i <= 3; i++) {
          rows.push({ label: `pillar_name:${i}`, belief: aimData.pillarNames[i] || '', confidence: '' });
        }
        // Lenses (if any).  Each lens is stored under lens:1, lens:2, etc.
        if (aimData.lenses && aimData.lenses.length > 0) {
          aimData.lenses.forEach((lensObj, idx) => {
            const belief = typeof lensObj.belief === 'string' ? lensObj.belief : '';
            const conf = (typeof lensObj.confidence === 'number') ? lensObj.confidence : '';
            // Join pillar attachments into a semicolon‑separated string for export
            let pillarsStr = '';
            if (Array.isArray(lensObj.pillars) && lensObj.pillars.length > 0) {
              pillarsStr = lensObj.pillars.join(';');
            }
            rows.push({ label: `lens:${idx + 1}`, belief: belief, confidence: conf, pillars: pillarsStr });
          });
        }
        // Core belief with confidence
        rows.push({ label: 'core', belief: aimData.core.belief || '', confidence: aimData.core.confidence || 50 });
        // Pillars with confidence
        for (let p = 1; p <= 3; p++) {
          rows.push({ label: `pillar:${p}`, belief: aimData.pillars[p].belief || '', confidence: aimData.pillars[p].confidence || 50 });
        }
        // Subs and micros with confidence
        for (let p = 1; p <= 3; p++) {
          for (let s = 1; s <= 3; s++) {
            rows.push({ label: `sub:${p}:${s}`, belief: aimData.subs[p][s].belief || '', confidence: aimData.subs[p][s].confidence || 50 });
            for (let m = 1; m <= 3; m++) {
              rows.push({ label: `micro:${p}:${s}:${m}`, belief: aimData.micros[p][s][m].belief || '', confidence: aimData.micros[p][s][m].confidence || 50 });
            }
          }
        }
        // Convert to CSV including the confidence column
        // Include the pillars column when exporting lenses.  The csvFormat
        // function will include empty values for non‑lens rows automatically.
        const csvContent = d3.csvFormat(rows, ['label','belief','confidence','pillars']);
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = (aimData.title ? aimData.title.replace(/\s+/g, '_') : 'aim_data') + '.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', event => {
      // If overlay is open, Esc closes overlay only
      if (tableOverlay.style.display === 'flex') {
        if (event.key === 'Escape') {
          tableOverlay.style.display = 'none';
          event.preventDefault();
        }
        return;
      }
      // Escape resets the map
      if (event.key === 'Escape') {
        currentState = 'A';
        selectedPillar = null;
        selectedSub = null;
        preselectedSub = null;
        // Also disable confidence heatmap on reset
        showConfidence = false;
        if (confidenceToggle) confidenceToggle.checked = false;
        updateChart();
        updateLegend();
        updateLenses();
        event.preventDefault();
      }
      // 1,2,3 keys open pillar focus
      if (event.key === '1' || event.key === '2' || event.key === '3') {
        const index = parseInt(event.key);
        if (aimData && index >= 1 && index <= 3) {
          currentState = 'B';
          selectedPillar = index;
          selectedSub = null;
          preselectedSub = null;
          updateChart();
          updateLegend();
          // Flash the sub ring to indicate navigation
          setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
        }
      }
    });

    // Object to store computed radii for the current state; used for flash effects
    let currentRingRadii = {
      A: { pillarStart: 0, pillarEnd: 0, subStart: 0, subEnd: 0, microStart: 0, microEnd: 0 },
      B: { center: 0, subStart: 0, subEnd: 0, microStart: 0, microEnd: 0 },
      C: { center: 0, microStart: 0, microEnd: 0 }
    };

    // Default CSV contents embedded as a template literal.  When the page
    // loads we attempt to parse this instead of performing a network fetch.
    const defaultCsvText = `label,belief
title,Acme Robotics
mode,business
pillar_name:1,Team
pillar_name:2,Revenue
pillar_name:3,Customer
core,"Be a calm, clear center that others can trust"
pillar:1,Hire for slope; train for excellence
pillar:2,Recurring revenue makes the weather boring
pillar:3,Delight is practical
sub:1:1,Leaders teach; they don’t rescue
sub:1:2,Slow is smooth; smooth is fast
sub:1:3,Raise the standard; shrink the task
sub:2:1,Price signals value
sub:2:2,Expand LTV before CAC
sub:2:3,Find friction; sell relief
sub:3:1,Onboarding is chapter one
sub:3:2,Reduce choices; raise confidence
sub:3:3,Close the loop
micro:1:1:1,Weekly 1:1s unlock roadblocks
micro:1:1:2,Empower through mentorship
micro:1:1:3,Feedback fosters growth
micro:1:2:1,Define clear priorities
micro:1:2:2,Repetition builds mastery
micro:1:2:3,Practice purposeful pacing
micro:1:3:1,Set higher expectations
micro:1:3:2,Focus on small wins
micro:1:3:3,Deliver incremental progress
micro:2:1:1,Price tiers communicate quality
micro:2:1:2,Transparent pricing builds trust
micro:2:1:3,Anchoring influences perception
micro:2:2:1,Strengthen existing customers
micro:2:2:2,Offer expansions before discounts
micro:2:2:3,Segment markets intelligently
micro:2:3:1,Map the buyer’s pain
micro:2:3:2,Remove purchase friction
micro:2:3:3,Provide clear ROI
micro:3:1:1,Make onboarding delightful
micro:3:1:2,Tailor first experiences
micro:3:1:3,Guide with contextual help
micro:3:2:1,Simplify choices
micro:3:2:2,Default to best practice
micro:3:2:3,Highlight recommendations
micro:3:3:1,Collect feedback proactively
micro:3:3:2,Respond within 24 hours
micro:3:3:3,Follow-up closes the loop`;

    // Parse the default CSV on load from the embedded string.  Avoids
    // reliance on file loading in the file:// scheme which may fail.  After
    // parsing, attempt to load a dataset specified via URL query parameters
    // (e.g. ?csv=custom.csv or ?data=BASE64ENCODEDCSV).  If a query
    // parameter is supplied and successfully parsed, it will replace the
    // default data.  Once data loading is complete, initialise the page.
    (async function() {
      try {
        const defaultRows = d3.csvParse(defaultCsvText);
        aimData = parseCSV(defaultRows);
      } catch (err) {
        console.error('Failed to parse embedded default CSV', err);
        aimData = null;
      }
      await loadFromQuery();
      initialisePage();
    })();

    /**
     * Parses CSV rows into a structured AIM object.
     * The input rows must have a `label` column (case-insensitive) and a
     * `belief` column.  The parser supports optional meta rows for title,
     * mode and pillar_name overrides.  Missing beliefs are left empty.
     */
    function parseCSV(rows) {
      const data = {
        title: '',
        mode: 'business',
        pillarNames: {},
        // core belief and its confidence
        core: { label: '', belief: '', confidence: 50 },
        // pillar, sub and micro structures each include belief and confidence
        pillars: {},
        subs: {},
        micros: {},
        // lenses array: arbitrary list of strings
        lenses: []
      };
      rows.forEach(row => {
        if (!row.label) return;
        const label = String(row.label).trim().toLowerCase();
        const belief = row.belief !== undefined ? String(row.belief).trim() : '';
        // Parse optional confidence column (0-100).  Default to 50 if missing or invalid
        let confidence = 50;
        if (row.confidence !== undefined && row.confidence !== '') {
          const num = parseFloat(row.confidence);
          if (!isNaN(num)) {
            confidence = Math.max(0, Math.min(100, num));
          }
        }
        if (label === 'title') {
          data.title = belief;
          return;
        }
        if (label === 'mode') {
          data.mode = belief.toLowerCase() === 'personal' ? 'personal' : 'business';
          return;
        }
        if (label.startsWith('pillar_name:')) {
          const idx = parseInt(label.split(':')[1]);
          if (idx >= 1 && idx <= 3) {
            data.pillarNames[idx] = belief;
          }
          return;
        }
        if (label === 'core') {
          // Store core belief and confidence
          data.core = { label: 'Core', belief: belief, confidence: confidence };
          return;
        }
        if (label.startsWith('pillar:')) {
          const idx = parseInt(label.split(':')[1]);
          if (!data.pillars[idx]) data.pillars[idx] = { belief: '', confidence: 50 };
          data.pillars[idx].belief = belief;
          data.pillars[idx].confidence = confidence;
          return;
        }
        if (label.startsWith('sub:')) {
          const parts = label.split(':');
          const p = parseInt(parts[1]);
          const s = parseInt(parts[2]);
          if (!data.subs[p]) data.subs[p] = {};
          if (!data.subs[p][s]) data.subs[p][s] = { belief: '', confidence: 50 };
          data.subs[p][s].belief = belief;
          data.subs[p][s].confidence = confidence;
          return;
        }
        if (label.startsWith('micro:')) {
          const parts = label.split(':');
          const p = parseInt(parts[1]);
          const s = parseInt(parts[2]);
          const m = parseInt(parts[3]);
          if (!data.micros[p]) data.micros[p] = {};
          if (!data.micros[p][s]) data.micros[p][s] = {};
          data.micros[p][s][m] = { belief: belief, confidence: confidence };
          return;
        }
        // Lenses: any label starting with 'lens' will be treated as a lens entry.
        // Lenses accept optional confidence values and pillar attachments.  If the
        // CSV includes a 'pillars' column, parse it as a comma/semicolon‑separated
        // list of pillar indices (1–3).  Each lens is stored as an object
        // containing the belief text, confidence and a list of associated
        // pillars.  Missing confidence defaults to 50 and missing pillars
        // default to an empty array.  Labels may be like 'lens', 'lens:1', etc.
        if (label.startsWith('lens')) {
          if (belief) {
            let pillarsList = [];
            // Attempt to parse pillars from row.pillars if present
            if (row.pillars !== undefined && row.pillars !== '') {
              const raw = String(row.pillars).trim();
              // Split on comma or semicolon
              raw.split(/[;,]/).forEach(part => {
                const val = parseInt(part.trim());
                if (!isNaN(val) && val >= 1 && val <= 3) {
                  pillarsList.push(val);
                }
              });
            }
            data.lenses.push({ belief: belief, confidence: confidence, pillars: pillarsList });
          }
          return;
        }
      });
      // Set default pillar names based on mode if missing
      const defaultNames = data.mode === 'personal'
        ? ['Outer Self','Inner Self','Relationships']
        : ['Team','Revenue','Customer'];
      for (let i = 1; i <= 3; i++) {
        if (!data.pillars[i]) data.pillars[i] = { belief: '', confidence: 50 };
        if (!data.pillarNames[i]) data.pillarNames[i] = defaultNames[i - 1];
        if (!data.subs[i]) data.subs[i] = {};
        if (!data.micros[i]) data.micros[i] = {};
        for (let j = 1; j <= 3; j++) {
          if (!data.subs[i][j]) data.subs[i][j] = { belief: '', confidence: 50 };
          if (!data.micros[i][j]) data.micros[i][j] = {};
          for (let k = 1; k <= 3; k++) {
            if (!data.micros[i][j][k]) data.micros[i][j][k] = { belief: '', confidence: 50 };
          }
        }
      }
      return data;
    }

    /**
     * Attempts to load a CSV dataset from the URL query parameters.  If
     * ?csv=filename is present, a fetch is issued to retrieve the file
     * relative to the page.  If ?data=base64 is present, the parameter
     * value is Base64‑decoded and parsed as CSV text.  If no query
     * parameters are provided or loading fails, the existing aimData
     * remains unchanged.  This function returns a promise so that the
     * caller can await its completion before rendering.
     */
    async function loadFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search);
        // Load from ?csv=filename.csv
        if (params.has('csv')) {
          const fileName = params.get('csv');
          if (fileName) {
            // Try to retrieve from localStorage first (works for file:// origin)
            try {
              const stored = localStorage.getItem('aim_csv_' + fileName);
              if (stored) {
                const rows = d3.csvParse(stored);
                aimData = parseCSV(rows);
                return;
              }
            } catch (err) {
              console.warn('Error reading CSV from localStorage:', err);
            }
            // Fall back to network fetch (works on hosted environments)
            try {
              const response = await fetch(fileName);
              if (!response.ok) {
                console.warn('Could not load CSV from', fileName, response.status);
              } else {
                const text = await response.text();
                const rows = d3.csvParse(text);
                aimData = parseCSV(rows);
                return;
              }
            } catch (err) {
              console.error('Error fetching CSV from query parameter:', err);
            }
          }
        }
        // Load from ?data=BASE64ENCODEDCSV
        if (params.has('data')) {
          const encoded = params.get('data');
          if (encoded) {
            try {
              // Decode from base64 (URL‑safe) and URI component decoding
              const decoded = atob(decodeURIComponent(encoded));
              const rows = d3.csvParse(decoded);
              aimData = parseCSV(rows);
              return;
            } catch (err) {
              console.error('Error decoding CSV data from query parameter:', err);
            }
          }
        }
      } catch (err) {
        console.error('Error processing query parameters:', err);
      }
    }

    /**
     * Handles file uploads from the file input.  The uploaded CSV is parsed
     * and replaces the current AIM dataset.  Errors are logged to the console.
     */
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const text = e.target.result;
          const rows = d3.csvParse(text);
          aimData = parseCSV(rows);
          // Reset view state
          currentState = 'A';
          selectedPillar = null;
          selectedSub = null;
          preselectedSub = null;
          // Persist the uploaded CSV content in localStorage keyed by file name
          try {
            const fileName = file.name;
            if (fileName) {
              localStorage.setItem('aim_csv_' + fileName, text);
              // Update the URL query to reference the uploaded file
              const basePath = window.location.pathname;
              const newUrl = basePath + '?csv=' + encodeURIComponent(fileName);
              window.history.replaceState(null, '', newUrl);
            }
          } catch (errStorage) {
            console.warn('Could not store uploaded CSV in localStorage:', errStorage);
          }
          initialisePage();
          // Reset the file input value so that selecting the same file again
          // triggers a change event.  Without this reset, re‑uploading the
          // same file may not fire the change event due to the input
          // retaining its previous value.
          event.target.value = '';
        } catch (err) {
          console.error('Error parsing uploaded CSV:', err);
        }
      };
      reader.readAsText(file);
    }

    /**
     * Initialise the page once the AIM data is loaded or replaced.  This
     * function populates the legend and renders the chart for the first time.
     */
    function initialisePage() {
      // Update page title
      // Build title: AIM (Aspirational Identity Map): <Name>.  If no name provided,
      // fall back to mode (Business/Personal) description.
      const name = aimData.title || '';
      let pageTitle;
      if (name) {
        pageTitle = `AIM (Aspirational Identity Map): ${name}`;
      } else {
        const modeLabel = aimData.mode === 'personal' ? 'Personal' : 'Business';
        pageTitle = `AIM (Aspirational Identity Map): ${modeLabel}`;
      }
      document.title = pageTitle;
      titleBar.text(pageTitle);
      // Render legend
      updateLegend();
      // Update the lenses block in the sidebar
      updateLenses();
      // Draw the chart
      updateChart();
    }

    /**
     * Populates the lenses section of the sidebar.  Displays a list of
     * lenses or a default message if no lenses are present.  A bullet
     * character precedes each lens for visual separation.
     */
    function updateLenses() {
      const listEl = document.getElementById('lensesList');
      if (!listEl) return;
      if (!aimData || !aimData.lenses || aimData.lenses.length === 0) {
        listEl.textContent = 'No lenses';
      } else {
        // Clear existing
        listEl.innerHTML = '';
        // Sort lenses by confidence descending and take top 5
        const sorted = aimData.lenses.slice().sort((a, b) => {
          const ca = (typeof a.confidence === 'number') ? a.confidence : 50;
          const cb = (typeof b.confidence === 'number') ? b.confidence : 50;
          return cb - ca;
        });
        const topLenses = sorted.slice(0, 5);
        topLenses.forEach(lens => {
          const container = document.createElement('div');
          container.style.display = 'flex';
          container.style.alignItems = 'center';
          container.style.gap = '6px';
          container.style.cursor = 'default';
          // Confidence dot: colour depends on heatmap state
          const dot = document.createElement('span');
          dot.style.display = 'inline-block';
          dot.style.width = '10px';
          dot.style.height = '10px';
          dot.style.borderRadius = '50%';
          let color;
          if (showConfidence) {
            const heat = computeHeatColor((typeof lens.confidence === 'number') ? lens.confidence : 50);
            color = `rgb(${heat[0]},${heat[1]},${heat[2]})`;
          } else {
            // neutral grey dot when confidence heatmap is off
            color = '#888888';
          }
          dot.style.backgroundColor = color;
          container.appendChild(dot);
          // Lens text (truncate long lenses for display).  Add title attribute to show full text on hover.
          const textSpan = document.createElement('span');
          const lensText = typeof lens.belief === 'string' ? lens.belief.trim() : '';
          const displayText = lensText.length > 50 ? lensText.slice(0, 47).trim() + '…' : lensText;
          textSpan.textContent = displayText;
          textSpan.style.flex = '1';
          textSpan.style.fontSize = '0.85rem';
          textSpan.style.color = '#333';
          // Use title attribute to show full lens text on hover
          textSpan.setAttribute('title', lensText);
          container.appendChild(textSpan);
          // Append small coloured squares for pillar attachments
          if (Array.isArray(lens.pillars) && lens.pillars.length > 0) {
            const attachContainer = document.createElement('span');
            attachContainer.style.display = 'flex';
            attachContainer.style.gap = '3px';
            lens.pillars.forEach(pillarIdx => {
              const sq = document.createElement('span');
              sq.style.display = 'inline-block';
              sq.style.width = '8px';
              sq.style.height = '8px';
              sq.style.borderRadius = '2px';
              const rgb = pillarBases[pillarIdx - 1] || [136,136,136];
              let attachColor;
              if (showConfidence) {
                const heat = computeHeatColor((typeof lens.confidence === 'number') ? lens.confidence : 50);
                attachColor = `rgb(${heat[0]},${heat[1]},${heat[2]})`;
              } else {
                attachColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
              }
              sq.style.backgroundColor = attachColor;
              attachContainer.appendChild(sq);
            });
            container.appendChild(attachContainer);
          }
          // Add custom tooltip events for lenses.  We reuse showTooltip/hideTooltip
          container.addEventListener('mouseenter', (e) => {
            showTooltip(e, lens);
          });
          container.addEventListener('mousemove', (e) => {
            moveTooltip(e);
          });
          container.addEventListener('mouseleave', (e) => {
            hideTooltip();
          });
          listEl.appendChild(container);
        });
      }
    }

    /**
     * Updates the legend chips based on the current AIM data and state.  The
     * legend indicates which pillar is active and supports hover and click
     * interactions to navigate to pillar focus.
     */
    function updateLegend() {
      if (!aimData) return;
      const data = [1,2,3];
      const chips = legendContainer.selectAll('.legend-chip').data(data);
      // Enter
      const chipsEnter = chips.enter().append('div')
        .attr('class','legend-chip')
        .attr('role','button')
        .attr('tabindex','0')
        .attr('aria-pressed','false')
        .on('click', (event, d) => {
          event.preventDefault();
          handleLegendClick(d);
        });
      chipsEnter.append('div').attr('class','dot');
      chipsEnter.append('div').attr('class','label');
      // Update
      const allChips = chipsEnter.merge(chips);
      allChips
        .classed('selected', d => d === selectedPillar)
        .each(function(d) {
          const chip = d3.select(this);
          chip.select('.dot').style('background-color', () => {
            const rgb = pillarBases[d-1];
            return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${depthAlpha[1]})`;
          });
          chip.select('.label').text(aimData.pillarNames[d] || '');
          chip.attr('aria-pressed', (d === selectedPillar).toString());
        });
    }

    /**
     * Handles clicks on legend chips.  Clicking a chip always brings the
     * corresponding pillar into focus (State B).  If already focused on that
     * pillar, no change occurs.  When in State C, clicking a legend chip
     * switches to pillar focus without going to State A first.
     */
    function handleLegendClick(pillarIdx) {
      if (!aimData) return;
      if (selectedPillar === pillarIdx && currentState === 'B') return;
      selectedPillar = pillarIdx;
      selectedSub = null;
      preselectedSub = null;
      currentState = 'B';
      updateChart();
      updateLegend();
      // Flash the sub ring to indicate navigation
      setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
    }

    /**
     * Computes the colour for a wedge based on its pillar index and depth.  The
     * colour parity rule is implemented here: each pillar’s base RGB is used
     * with a depth‑specific alpha value.  See the spec for exact values.
     */
    function computeFill(pillarIdx, depth) {
      const base = pillarBases[pillarIdx - 1];
      const alpha = depthAlpha[depth];
      return `rgba(${base[0]},${base[1]},${base[2]},${alpha})`;
    }

    /**
     * Compute radii for the current view based on the SVG size.  This helper
     * returns an object containing inner and outer radii for each ring in each
     * state.  Radii are computed as fractions of the available radius so the
     * chart scales with its container.  Small gaps are inserted between rings
     * to visually separate layers.
     */
    function computeRadii() {
      // The chart should remain square.  Compute the available size from the
      // parent container rather than the SVG itself (which may have zero
      // height if not explicitly sized).  Then set the SVG’s width and
      // height to enforce a square aspect ratio.
      /*
       * The chart must remain square and always fully visible on first load.  When
       * computing available space, the parent wrapper’s width can be zero if the
       * DOM has not finished layout (e.g. on first paint).  To avoid
       * collapsing to an infinitesimal size we estimate the width from the
       * container minus the sidebar.  The height is derived from the
       * viewport minus the header.  We then clamp the square size to the
       * lesser of these two values.  This approach ensures the graphic
       * appears at a consistent size at the top of the page and never
       * overflows the viewport.
       */
      const chartWrapper = svg.node().parentNode;
      const containerEl = document.getElementById('container');
      const sidebarEl = document.getElementById('sidebar');
      const titleBarEl = document.getElementById('titleBar');
      // Use the actual wrapper width if available; otherwise approximate from container
      const parentRect = chartWrapper.getBoundingClientRect();
      let containerWidth = containerEl ? containerEl.getBoundingClientRect().width : 0;
      let sidebarWidth = sidebarEl ? sidebarEl.getBoundingClientRect().width : 0;
      // If parentRect.width is 0 (layout not ready), fall back to container width minus sidebar
      let availableWidth = parentRect.width > 0 ? parentRect.width : Math.max(containerWidth - sidebarWidth - 32, 300);
      // Compute available height: viewport minus header and some padding
      const headerHeight = titleBarEl ? titleBarEl.getBoundingClientRect().height : 0;
      // 40px padding for margins
      let availableHeight = Math.max(window.innerHeight - headerHeight - 40, 300);
      const size = Math.min(availableWidth, availableHeight);
      // Apply the computed size to the SVG so subsequent calculations use
      // consistent dimensions.  Also set the wrapper height to maintain the
      // square area.
      svg.attr('width', size).attr('height', size);
      chartWrapper.style.height = size + 'px';
      const margin = 4; // small margin to avoid clipping
      const radius = (size / 2) - margin;
      // Define ring proportion constants for each state.  We allocate
      // significantly more space to the central disc and the ring of three
      // beliefs, while shrinking the sub and micro rings.  Ratios must
      // sum to 1.0.  Feel free to tweak these values to adjust legibility.
      // Global state (A): [core, pillar (3), sub (9), micro (27)]
      // Increase space for the core and pillar rings while shrinking the
      // outer rings.  These ratios sum to 1.0 and provide 45% of the
      // radius to the core, 35% to the ring of three, 15% to the sub
      // ring and 5% to the micro ring in the global view.  In pillar
      // focus, the centre receives 50%, subs 35% and micros 15%.  In
      // sub focus the centre uses 70% and the micro ring 30%.
    // Allocate more space to the core and the ring of three in the global view.  The
    // ratios represent [core, pillar (3), sub (9), micro (27)] and must sum to 1.0.
    // We dedicate 50% of the radius to the core disc, 35% to the ring of three,
    // leaving just 10% for the sub ring and 5% for the micro ring.  This
    // reduces clutter in the outer rings while giving text in the centre more
    // breathing room.
    const globalRatios = [0.50, 0.35, 0.10, 0.05];
      // Pillar focus (B): centre (pillar), sub ring (three subs), micro ring (nine micros)
    // Pillar focus: favour the centre and the ring of three subs.  We give
    // 55% to the centre, 35% to the sub ring and shrink the micro ring to
    // 10% of the radius.
    const bRatios = [0.55, 0.35, 0.10];
      // Sub focus (C): centre (sub) and micro ring (three micros)
    // Sub focus: emphasise the selected sub while leaving space for its three
    // micros.  Allocate 75% of the radius to the centre and the remaining
    // 25% to the micro ring.
    const cRatios = [0.75, 0.25];
      const gap = 2; // small gap between rings
      // Compute radii for global state
      let cumulative = 0;
      const rA1 = radius * globalRatios[0];
      const rA2 = rA1 + radius * globalRatios[1];
      const rA3 = rA2 + radius * globalRatios[2];
      const globalRadii = {
        coreEnd: rA1 - gap,
        pillarStart: rA1,
        pillarEnd: rA2 - gap,
        subStart: rA2,
        subEnd: rA3 - gap,
        microStart: rA3,
        microEnd: radius
      };
      // Compute radii for pillar focus
      const bR1 = radius * bRatios[0];
      const bR2 = bR1 + radius * bRatios[1];
      const pillarRadii = {
        center: bR1 - gap,
        subStart: bR1,
        subEnd: bR2 - gap,
        microStart: bR2,
        microEnd: radius
      };
      // Compute radii for sub focus
      const cR1 = radius * cRatios[0];
      const subRadii = {
        center: cR1 - gap,
        microStart: cR1,
        microEnd: radius
      };
      return { A: globalRadii, B: pillarRadii, C: subRadii };
    }

    /**
     * Computes an array of arc descriptors representing all wedges to be drawn
     * in the current state.  Each descriptor contains angular and radial
     * boundaries, hierarchy indices (pillar/sub/micro) and associated beliefs.
     */
    function computeArcDescriptors() {
      const descriptors = [];
      const twoPi = Math.PI * 2;
      if (!aimData) return descriptors;
      // Compute radii and cache for flash effects
      currentRingRadii = computeRadii();
      const radii = currentRingRadii[currentState];
      if (currentState === 'A') {
        // Global view: draw all depth 1, 2 and 3 wedges
        const majorStep = twoPi / 3;        // 120° per pillar
        const subStep = majorStep / 3;       // 40° per sub
        const microStep = subStep / 3;       // 13.33° per micro
        // Pillars
        for (let p = 1; p <= 3; p++) {
          const start = (p - 1) * majorStep;
          const end = p * majorStep;
          const belief = aimData.pillars[p].belief;
          const conf = aimData.pillars[p].confidence || 50;
          const label = truncateText(belief, maxCharsByDepth[1]);
          descriptors.push({
            depth: 1,
            pillar: p,
            startAngle: start,
            endAngle: end,
            innerRadius: radii.pillarStart,
            outerRadius: radii.pillarEnd,
            belief: belief,
            label: label,
            confidence: conf,
            sub: null,
            micro: null,
            showLabel: true
          });
          // Subs
          for (let s = 1; s <= 3; s++) {
            const sStart = start + (s - 1) * subStep;
            const sEnd = sStart + subStep;
            const beliefSub = aimData.subs[p][s].belief;
            const confSub = aimData.subs[p][s].confidence || 50;
            const labelSub = truncateText(beliefSub, maxCharsByDepth[2]);
            descriptors.push({
              depth: 2,
              pillar: p,
              sub: s,
              startAngle: sStart,
              endAngle: sEnd,
              innerRadius: radii.subStart,
              outerRadius: radii.subEnd,
              belief: beliefSub,
              label: labelSub,
              confidence: confSub,
              micro: null,
              showLabel: false
            });
            // Micros
            for (let m = 1; m <= 3; m++) {
              const mStart = sStart + (m - 1) * microStep;
              const mEnd = mStart + microStep;
              const beliefMicro = aimData.micros[p][s][m].belief;
              const confMicro = aimData.micros[p][s][m].confidence || 50;
              const labelMicro = truncateText(beliefMicro, maxCharsByDepth[3]);
              descriptors.push({
                depth: 3,
                pillar: p,
                sub: s,
                micro: m,
                startAngle: mStart,
                endAngle: mEnd,
                innerRadius: radii.microStart,
                outerRadius: radii.microEnd,
                belief: beliefMicro,
                label: labelMicro,
                confidence: confMicro,
                showLabel: false
              });
            }
          }
        }
      } else if (currentState === 'B' && selectedPillar) {
        // Pillar focus: centre shows the pillar; one ring for its 3 subs; outer ring for its 9 micros
        const p = selectedPillar;
        // Sub and micro angles span full circle
        const subStep = twoPi / 3;         // 120° per sub (3 subs)
        const microStep = twoPi / 9;       // 40° per micro (9 micros)
        // Subs
        for (let s = 1; s <= 3; s++) {
          const sStart = (s - 1) * subStep;
          const sEnd = sStart + subStep;
          const beliefSub = aimData.subs[p][s].belief;
          const confSub = aimData.subs[p][s].confidence || 50;
          const labelSub = truncateText(beliefSub, maxCharsByDepth[2]);
          descriptors.push({
            depth: 2,
            pillar: p,
            sub: s,
            startAngle: sStart,
            endAngle: sEnd,
            innerRadius: radii.subStart,
            outerRadius: radii.subEnd,
            belief: beliefSub,
            label: labelSub,
            confidence: confSub,
            micro: null,
            showLabel: true
          });
          // Micros (3 per sub; repeated to make 9 arcs; no labels)
          for (let m = 1; m <= 3; m++) {
            for (let repeat = 0; repeat < 3; repeat++) {
              const idx = (s - 1) * 3 + (m - 1) * 3 + repeat;
              const mStart = idx * microStep;
              const mEnd = mStart + microStep;
              const beliefMicro = aimData.micros[p][s][m].belief;
              const confMicro = aimData.micros[p][s][m].confidence || 50;
              const labelMicro = truncateText(beliefMicro, maxCharsByDepth[3]);
              descriptors.push({
                depth: 3,
                pillar: p,
                sub: s,
                micro: m,
                startAngle: mStart,
                endAngle: mEnd,
                innerRadius: radii.microStart,
                outerRadius: radii.microEnd,
                belief: beliefMicro,
                label: labelMicro,
                confidence: confMicro,
                showLabel: false
              });
            }
          }
        }
      } else if (currentState === 'C' && selectedPillar && selectedSub) {
        // Sub focus: centre shows selected sub; outer ring shows its 3 micros equally spaced
        const p = selectedPillar;
        const s = selectedSub;
        const microStep = twoPi / 3;
        for (let m = 1; m <= 3; m++) {
          const mStart = (m - 1) * microStep;
          const mEnd = mStart + microStep;
          const beliefMicro = aimData.micros[p][s][m].belief;
          const confMicro = aimData.micros[p][s][m].confidence || 50;
          const labelMicro = truncateText(beliefMicro, maxCharsByDepth[3]);
          descriptors.push({
            depth: 3,
            pillar: p,
            sub: s,
            micro: m,
            startAngle: mStart,
            endAngle: mEnd,
            innerRadius: radii.microStart,
            outerRadius: radii.microEnd,
            belief: beliefMicro,
            label: labelMicro,
            confidence: confMicro,
            showLabel: true
          });
        }
      }
      return descriptors;
    }

    /**
     * Updates the chart by computing descriptors for the current state and
     * binding them to SVG paths.  This function also attaches event handlers
     * for hover and click interactions.  The arcs are keyed by a composite
     * string to ensure stable joins across updates.
     */
    function updateChart() {
      if (!aimData) return;
      // Compute descriptors for the current state; computeRadii() will update the SVG
      const descriptors = computeArcDescriptors();

      // Remove any existing groups; create group structure fresh
      svg.selectAll('*').remove();
      const g = svg.append('g')
        .attr('class','arcs')
        // centre the coordinate system based on the newly sized SVG
        .attr('transform', () => {
          const bbox = svg.node().getBoundingClientRect();
          return `translate(${bbox.width / 2},${bbox.height / 2})`;
        });
      // For accessibility, we attach a tabindex to each path if clickable
      const arcs = g.selectAll('path.wedge')
        .data(descriptors, d => `${d.depth}-${d.pillar}-${d.sub || 0}-${d.micro || 0}-${d.startAngle}`)
        .join('path')
        .attr('class','wedge')
        .attr('d', d => {
          return d3.arc()({
            innerRadius: d.innerRadius,
            outerRadius: d.outerRadius,
            startAngle: d.startAngle,
            endAngle: d.endAngle
          });
        })
        .attr('fill', d => computeFillColor(d))
        .attr('stroke', 'none')
        .attr('tabindex', d => {
          // Only make wedges focusable if they are clickable
          if (currentState === 'A' && (d.depth === 1 || d.depth === 2)) return 0;
          if (currentState === 'B' && d.depth === 2) return 0;
          return -1;
        })
        .style('cursor', d => {
          if (currentState === 'A' && (d.depth === 1 || d.depth === 2)) return 'pointer';
          if (currentState === 'B' && d.depth === 2) return 'pointer';
          return 'default';
        })
        .on('mouseover', function(event, d) {
          showTooltip(event, d);
          // Pulse legend chip for hovered wedge’s pillar
          highlightLegendChip(d.pillar);
        })
        .on('mousemove', function(event) {
          moveTooltip(event);
        })
        .on('mouseout', function(event, d) {
          hideTooltip();
          removeLegendHighlight();
        })
        .on('click', function(event, d) {
          event.preventDefault();
          handleArcClick(d);
        });
      // Add separators for current state
      drawSeparators(g);
      // Draw centre labels for States B and C
      drawCenterText(g);
      // Draw labels inside selected wedges
      drawArcLabels(g, descriptors);

      // Add an invisible disc over the centre to enable tooltips on the centre
      addCenterHover(g);
    }

    /**
     * Draws radial separators between wedges according to the current state.
     * Separators are implemented as SVG lines or paths with specified
     * strokes and opacities.  Major separators separate pillars, minor
     * separators separate subs and micro separators separate micros.
     */
    function drawSeparators(g) {
      const radii = currentRingRadii[currentState];
      const twoPi = Math.PI * 2;
      // Helper to convert polar coords to Cartesian
      const polarToCartesian = (angle, radius) => {
        const x = Math.cos(angle - Math.PI / 2) * radius;
        const y = Math.sin(angle - Math.PI / 2) * radius;
        return [x, y];
      };
      if (currentState === 'A') {
        const majorAngles = [0, 2 * Math.PI / 3, 4 * Math.PI / 3];
        const minorAngles = [];
        const microAngles = [];
        // Sub boundaries
        const subStep = (2 * Math.PI) / 3 / 3; // 40°
        for (let i = 0; i < 3; i++) {
          const base = i * (2 * Math.PI / 3);
          minorAngles.push(base + subStep);
          minorAngles.push(base + subStep * 2);
          // Micro boundaries within each sub
          const microStep = subStep / 3;
          for (let j = 0; j < 3; j++) {
            const microBase = base + j * subStep;
            microAngles.push(microBase + microStep);
            microAngles.push(microBase + microStep * 2);
          }
        }
        // Draw major separators from core to outermost
        majorAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.pillarStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.30)')
            .attr('stroke-width', 1.6);
        });
        // Minor separators from sub ring to outer ring
        minorAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.subStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.22)')
            .attr('stroke-width', 1.2);
        });
        // Micro separators from micro ring start to micro ring end
        microAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.microStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.18)')
            .attr('stroke-width', 1.0);
        });
      } else if (currentState === 'B') {
        // In pillar focus we draw separators between the 3 subs (120° each)
        // and between the 9 micro segments (40° each).  Include angle 0 so a
        // vertical line is visible at the top of the circle.
        const subStep = (2 * Math.PI) / 3;
        const microStep = (2 * Math.PI) / 9;
        const subAngles = [0, subStep, subStep * 2];
        const microAngles = [];
        for (let k = 0; k < 9; k++) {
          // Skip the full circle micro boundary at 2π (same as 0)
          const angle = microStep * k;
          microAngles.push(angle);
        }
        // Draw sub separators from sub ring start to outer ring end
        subAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.subStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.22)')
            .attr('stroke-width', 1.2);
        });
        // Draw micro separators from micro ring start to micro ring end
        microAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.microStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.18)')
            .attr('stroke-width', 1.0);
        });
      } else if (currentState === 'C') {
        // In sub focus we draw separators between the 3 micro wedges.  Include angle 0
        const microStep = (2 * Math.PI) / 3;
        const angles = [0, microStep, microStep * 2];
        angles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.microStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.18)')
            .attr('stroke-width', 1.0);
        });
      }
    }

    /**
     * Draws the centre text for the focus states.  In pillar focus (B) the
     * centre displays the selected pillar’s belief text.  In sub focus (C)
     * the centre displays the selected sub’s belief text and its parent
     * pillar name.  In global state (A) nothing is drawn in the centre.
     */
    function drawCenterText(g) {
      if (currentState === 'A') {
        // Global view: show a "Core" label followed by the truncated core belief.
        const radii = currentRingRadii.A;
        const textGroup = g.append('g').attr('pointer-events','none');
        const coreBeliefFull = aimData.core.belief || '';
        // Truncate the core belief to the configured maximum characters
        const truncated = truncateText(coreBeliefFull, centerMaxChars);
        // Determine a wrap length based on the radius to prevent overflow
        const wrapLen = Math.max(8, Math.floor(radii.coreEnd / 8));
        const beliefLines = wrapLines(truncated, wrapLen);
        // Build array of lines: first the label, then the belief lines
        const lines = ['Core', ...beliefLines];
        // Compute font size relative to radius and number of lines
        const fontSize = Math.min(radii.coreEnd / (lines.length + 1), 18);
        const textEl = textGroup.append('text')
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('font-size', fontSize + 'px')
          .style('fill','#111');
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? -(lines.length - 1) / 2 * (fontSize + 2) : (fontSize + 2))
            .style('font-weight', i === 0 ? '700' : '400')
            .text(line);
        });
      } else if (currentState === 'B' && selectedPillar) {
        // Pillar focus: show the pillar name and truncated pillar belief.
        const radii = currentRingRadii.B;
        const textGroup = g.append('g').attr('pointer-events','none');
        const pillarLabel = aimData.pillarNames[selectedPillar] || '';
        const pillarBeliefFull = aimData.pillars[selectedPillar].belief || '';
        // Truncate the pillar belief and wrap relative to radius
        const truncated = truncateText(pillarBeliefFull, centerMaxChars);
        const wrapLen = Math.max(8, Math.floor(radii.center / 8));
        const beliefLines = wrapLines(truncated, wrapLen);
        const lines = [pillarLabel, ...beliefLines];
        const fontSize = Math.min(radii.center / (lines.length + 1), 18);
        const textEl = textGroup.append('text')
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('font-size', fontSize + 'px')
          .style('fill','#111');
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? -(lines.length - 1) / 2 * (fontSize + 2) : (fontSize + 2))
            .style('font-weight', i === 0 ? '700' : '400')
            .text(line);
        });
      } else if (currentState === 'C' && selectedPillar && selectedSub) {
        // Sub focus: show the truncated sub belief only.
        const radii = currentRingRadii.C;
        const textGroup = g.append('g').attr('pointer-events','none');
        const subBeliefFull = aimData.subs[selectedPillar][selectedSub].belief || '';
        const truncated = truncateText(subBeliefFull, centerMaxChars);
        const wrapLen = Math.max(8, Math.floor(radii.center / 8));
        const lines = wrapLines(truncated, wrapLen);
        const fontSize = Math.min(radii.center / (lines.length + 1), 18);
        const textEl = textGroup.append('text')
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('font-size', fontSize + 'px')
          .style('fill','#111');
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? -(lines.length - 1) / 2 * (fontSize + 2) : (fontSize + 2))
            .style('font-weight','400')
            .text(line);
        });
      }
    }

    /**
     * Simple text wrapping helper.  Splits a string into multiple lines
     * attempting to keep each line under maxLen characters.  Words are not
     * broken mid‑token.  If no spaces are present within a segment, the
     * overflow will simply spill onto the next line.
     *
     * @param {string} text The text to wrap
     * @param {number} maxLen Approximate maximum characters per line
     * @returns {string[]} Array of lines
     */
    function wrapLines(text, maxLen) {
      if (!text) return [''];
      const words = text.split(/\s+/);
      const lines = [];
      let current = '';
      words.forEach(word => {
        if (current.length > 0 && (current + ' ' + word).length > maxLen) {
          lines.push(current);
          current = word;
        } else {
          current = current.length > 0 ? current + ' ' + word : word;
        }
      });
      if (current.length > 0) lines.push(current);
      return lines;
    }

    /**
     * Truncates a string to a maximum number of characters, appending an
     * ellipsis when the original string exceeds that length.  Attempts
     * to avoid cutting a word mid‑token by truncating at the last
     * space within the limit where possible.
     *
     * @param {string} text The text to truncate
     * @param {number} maxChars Maximum characters to keep
     * @returns {string} The truncated text with ellipsis if needed
     */
    function truncateText(text, maxChars) {
      if (!text) return '';
      if (text.length <= maxChars) return text;
      let truncated = text.slice(0, maxChars);
      const lastSpace = truncated.lastIndexOf(' ');
      if (lastSpace > 5) {
        truncated = truncated.slice(0, lastSpace);
      }
      return truncated.trim() + '…';
    }

    /**
     * Handles clicks on wedges by updating the state machine.  Clicking on
     * pillars or subs in the global state zooms into the pillar focus.  A
     * subsequent click on a sub when in pillar focus zooms into the sub
     * focus.  Micros are not clickable.  The legend and chart are
     * re-rendered accordingly and a flash effect is triggered on the
     * appropriate ring.
     */
    function handleArcClick(d) {
      if (currentState === 'A') {
        if (d.depth === 1) {
          // Click on a pillar: go to pillar focus
          selectedPillar = d.pillar;
          selectedSub = null;
          preselectedSub = null;
          currentState = 'B';
          updateChart();
          updateLegend();
          // Flash sub ring
          setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
        } else if (d.depth === 2) {
          // Click on a sub: go to pillar focus with this sub preselected
          selectedPillar = d.pillar;
          selectedSub = null;
          preselectedSub = d.sub;
          currentState = 'B';
          updateChart();
          updateLegend();
          // Flash sub ring
          setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
        }
      } else if (currentState === 'B' && d.pillar === selectedPillar) {
        if (d.depth === 2) {
          // If preselectedSub exists and matches, go directly to sub focus
          if (preselectedSub && preselectedSub === d.sub) {
            selectedSub = d.sub;
            currentState = 'C';
            preselectedSub = null;
            updateChart();
            updateLegend();
            // Flash micro ring in sub focus
            setTimeout(() => flashRing(currentRingRadii.C.microStart, currentRingRadii.C.microEnd), 0);
          } else {
            // If no preselection, go to sub focus directly
            selectedSub = d.sub;
            preselectedSub = null;
            currentState = 'C';
            updateChart();
            updateLegend();
            setTimeout(() => flashRing(currentRingRadii.C.microStart, currentRingRadii.C.microEnd), 0);
          }
        }
      }
    }

    /**
     * Draw labels inside wedges for those descriptors marked with showLabel.
     * Labels are centred at the centroid of each arc and are wrapped
     * heuristically based on character count and ring thickness.  No labels
     * are drawn for micros in state A/B or subs in state A.
     */
    function drawArcLabels(g, descriptors) {
      const labelDescs = descriptors.filter(d => d.showLabel);
      labelDescs.forEach(d => {
        // Compute centroid of the arc using d3.arc().centroid
        const arcGen = d3.arc();
        const centroid = arcGen.centroid(d);
        // Compute an approximate font size based on ring thickness
        const thickness = d.outerRadius - d.innerRadius;
        const fontSize = Math.min(thickness / 3, 16);
        // Estimate a character limit for each line based on the arc length.  The
        // arc length is approximated by the average radius multiplied by the
        // angular span.  Divide by ~8 pixels per character to get a rough
        // character count.  Clamp between 8 and 24 to avoid extremes.
        const arcLength = (d.endAngle - d.startAngle) * ((d.innerRadius + d.outerRadius) / 2);
        // Clamp between 8 and 16 characters.  Keeping lines shorter helps
        // prevent text spilling outside narrow wedges.
        const charLimit = Math.max(8, Math.min(16, Math.floor(arcLength / 8)));
        // Wrap the truncated label rather than the full belief.  This
        // prevents overflow and ensures ellipses are shown consistently.  If
        // d.label is empty, fall back to the belief.
        const baseText = d.label && d.label.trim().length > 0 ? d.label : d.belief;
        const lines = wrapLines(baseText, charLimit);
        const lineHeight = fontSize + 2;
        const text = g.append('text')
          .attr('transform', `translate(${centroid[0]},${centroid[1]})`)
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('pointer-events','none')
          .style('fill','#111')
          .style('font-size', fontSize + 'px');
        lines.forEach((line, i) => {
          text.append('tspan')
            .attr('x', 0)
            .attr('dy', (i === 0 ? -(lines.length - 1) / 2 * lineHeight : lineHeight))
            .text(line);
        });
      });
    }

    /**
     * Adds an invisible disc over the centre of the chart so that the
     * core/pillar/sub belief can show a tooltip on hover.  The disc’s
     * radius is derived from the current state’s centre radius.  The
     * tooltip displays the full belief text along with its breadcrumb
     * path.  Without this overlay the centre belief has no interactive
     * element to trigger a tooltip.
     *
     * @param {Object} g D3 selection of the current SVG group
     */
    function addCenterHover(g) {
      if (!aimData) return;
      let radius = 0;
      if (currentState === 'A') {
        radius = currentRingRadii.A.coreEnd;
      } else if (currentState === 'B') {
        radius = currentRingRadii.B.center;
      } else if (currentState === 'C') {
        radius = currentRingRadii.C.center;
      }
      if (radius <= 0) return;
      // Determine the descriptor for the centre based on the state
      function getCenterDescriptor() {
        if (currentState === 'A') {
          return { belief: aimData.core.belief || '', pillar: null, sub: null, micro: null };
        } else if (currentState === 'B' && selectedPillar) {
          return { belief: aimData.pillars[selectedPillar].belief || '', pillar: selectedPillar, sub: null, micro: null };
        } else if (currentState === 'C' && selectedPillar && selectedSub) {
          return { belief: aimData.subs[selectedPillar][selectedSub].belief || '', pillar: selectedPillar, sub: selectedSub, micro: null };
        }
        return { belief: '', pillar: null, sub: null, micro: null };
      }
      g.append('circle')
        .attr('r', radius)
        .attr('fill', 'transparent')
        .attr('pointer-events', 'all')
        .on('mouseover', function(event) {
          const desc = getCenterDescriptor();
          showTooltip(event, desc);
        })
        .on('mousemove', function(event) {
          moveTooltip(event);
        })
        .on('mouseout', function() {
          hideTooltip();
        });
    }

    /**
     * Shows the tooltip near the pointer with the belief text and breadcrumb.
     */
    function showTooltip(event, d) {
      if (!d || !aimData) return;
      tooltip.style('display','block');
      let html = '';
      // Determine if this is a lens tooltip by checking for a pillars array and absence of hierarchical indices
      const isLens = d.hasOwnProperty('pillars') && !d.hasOwnProperty('pillar');
      if (isLens) {
        // Lens tooltip: show full lens text and its associated pillars
        const lensText = d.belief || '';
        html += `<div style="font-size:15px; font-weight:600; margin-bottom:4px;">${lensText}</div>`;
        // If attachments exist, list the pillar names
        if (Array.isArray(d.pillars) && d.pillars.length > 0) {
          const names = d.pillars.map(idx => aimData.pillarNames[idx] || '').filter(s => s);
          if (names.length > 0) {
            html += `<div style="font-size:12px; color:#555;">Applies to: ${names.join(', ')}</div>`;
          }
        }
      } else {
        // Arc tooltip: show the hovered belief and its parent only
        // Determine current and parent levels
        let currentLabel = 'Core';
        let currentText = aimData.core.belief || '';
        let parentLabel = '';
        let parentText = '';
        if (d.micro) {
          currentLabel = 'Micro';
          currentText = aimData.micros[d.pillar][d.sub][d.micro].belief || '';
          parentLabel = 'Sub';
          parentText = aimData.subs[d.pillar][d.sub].belief || '';
        } else if (d.sub) {
          currentLabel = 'Sub';
          currentText = aimData.subs[d.pillar][d.sub].belief || '';
          parentLabel = 'Pillar';
          parentText = aimData.pillars[d.pillar].belief || '';
        } else if (d.pillar) {
          currentLabel = 'Pillar';
          currentText = aimData.pillars[d.pillar].belief || '';
          parentLabel = 'Core';
          parentText = aimData.core.belief || '';
        } else {
          // Core belief
          currentLabel = 'Core';
          currentText = aimData.core.belief || '';
          parentLabel = '';
          parentText = '';
        }
        // Build HTML with larger font for hovered item
        html += `<div style="font-size:18px; font-weight:700; margin-bottom:4px;">`;
        if (currentLabel) {
          html += `<strong>${currentLabel}:</strong> `;
        }
        html += `${currentText}</div>`;
        if (parentText) {
          html += `<div style="font-size:14px; color:#555;">`;
          if (parentLabel) {
            html += `<strong>${parentLabel}:</strong> `;
          }
          html += `${parentText}</div>`;
        }
      }
      tooltip.html(html);
      moveTooltip(event);
    }

    /**
     * Moves the tooltip relative to the pointer position and clamps it to the
     * viewport.  This helper is called on mousemove.
     */
    function moveTooltip(event) {
      const tooltipNode = tooltip.node();
      const padding = 12;
      const tooltipRect = tooltipNode.getBoundingClientRect();
      let x = event.clientX + 14;
      let y = event.clientY + 14;
      const viewportWidth = document.documentElement.clientWidth;
      const viewportHeight = document.documentElement.clientHeight;
      // Clamp horizontally
      if (x + tooltipRect.width + padding > viewportWidth) {
        x = viewportWidth - tooltipRect.width - padding;
      }
      // Clamp vertically
      if (y + tooltipRect.height + padding > viewportHeight) {
        y = viewportHeight - tooltipRect.height - padding;
      }
      tooltip.style('left', x + 'px').style('top', y + 'px');
    }

    /** Hides the tooltip. */
    function hideTooltip() {
      tooltip.style('display','none');
    }

    /**
     * Highlights the legend chip belonging to the given pillar index by
     * temporarily outlining it.  This is used on hover to pulse the chip.
     */
    function highlightLegendChip(pillarIdx) {
      legendContainer.selectAll('.legend-chip').classed('hovered', d => d === pillarIdx);
      // Add outline style via inline border; removed on mouseout
      legendContainer.selectAll('.legend-chip').each(function(d) {
        const chip = d3.select(this);
        if (d === pillarIdx) {
          chip.select('.dot').style('outline', `2px solid rgba(${pillarBases[d-1][0]},${pillarBases[d-1][1]},${pillarBases[d-1][2]},1)`);
        }
      });
    }
    /**
     * Removes any temporary highlight from legend chips.
     */
    function removeLegendHighlight() {
      legendContainer.selectAll('.legend-chip .dot').style('outline', 'none');
    }

    /**
     * Creates a quick flash on the destination ring to confirm navigation.  A
     * translucent ring is drawn and faded out.  The ring is defined by its
     * inner and outer radii.  This helper schedules its own removal.
     */
    function flashRing(innerR, outerR) {
      const g = svg.select('g.arcs');
      if (g.empty()) return;
      const path = d3.arc()({
        innerRadius: innerR,
        outerRadius: outerR,
        startAngle: 0,
        endAngle: Math.PI * 2
      });
      const flash = g.append('path')
        .attr('d', path)
        .attr('fill', 'rgba(255,255,255,0.3)')
        .attr('pointer-events','none');
      flash.transition()
        .duration(150)
        .attr('fill', 'rgba(255,255,255,0)')
        .remove();
    }

    /**
     * Builds the table view overlay showing all nodes with their hierarchical
     * coordinates.  The table is sorted by depth and then pillar/sub/micro.
     */
    function buildTableView() {
      if (!aimData) return;
      // Flatten nodes into an array for the table
      const rows = [];
      // Core
      rows.push({ depth: 0, pillar: '', sub: '', micro: '', label: 'Core', belief: aimData.core.belief || '', confidence: aimData.core.confidence || 50 });
      for (let p = 1; p <= 3; p++) {
        // Pillar with confidence
        rows.push({ depth: 1, pillar: p, sub: '', micro: '', label: aimData.pillarNames[p] || '', belief: aimData.pillars[p].belief || '', confidence: aimData.pillars[p].confidence || 50 });
        for (let s = 1; s <= 3; s++) {
          // Sub with confidence
          rows.push({ depth: 2, pillar: p, sub: s, micro: '', label: '', belief: aimData.subs[p][s].belief || '', confidence: aimData.subs[p][s].confidence || 50 });
          for (let m = 1; m <= 3; m++) {
            // Micro with confidence
            rows.push({ depth: 3, pillar: p, sub: s, micro: m, label: '', belief: aimData.micros[p][s][m].belief || '', confidence: aimData.micros[p][s][m].confidence || 50 });
          }
        }
      }
      // Sort by depth then pillar/sub/micro
      rows.sort((a,b) => {
        if (a.depth !== b.depth) return a.depth - b.depth;
        if (a.pillar !== b.pillar) return (a.pillar || 0) - (b.pillar || 0);
        if (a.sub !== b.sub) return (a.sub || 0) - (b.sub || 0);
        if (a.micro !== b.micro) return (a.micro || 0) - (b.micro || 0);
        return 0;
      });
      // Populate table body
      tableBody.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${r.depth}</td><td>${r.pillar || ''}</td><td>${r.sub || ''}</td><td>${r.micro || ''}</td><td>${r.label}</td><td>${r.belief}</td><td>${r.confidence !== undefined ? r.confidence : ''}</td>`;
        tableBody.appendChild(tr);
      });
    }

    /**
     * Filters the table rows based on the search string.  Only beliefs that
     * include the search term (case‑insensitive) remain visible.
     */
    function filterTable(search) {
      const trs = tableBody.querySelectorAll('tr');
      trs.forEach(tr => {
        const belief = tr.children[5].textContent.toLowerCase();
        if (!search || belief.indexOf(search) !== -1) {
          tr.style.display = '';
        } else {
          tr.style.display = 'none';
        }
      });
    }
  })();
  </script>
</body>
</html>