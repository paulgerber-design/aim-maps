<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!--
    This file implements an interactive Aspirational Identity Map (AIM) as a three‑ring
    sunburst diagram.  The specification for this visualization is defined in the
    accompanying product spec.  The implementation uses D3.js for drawing arcs
    and handling user interactions.  See the accompanying JavaScript code at
    the bottom of this file for details.  The colour palette and ring sizing
    originate from the specification, while the layout adapts responsively
    to smaller screens.  All strings, labels and beliefs are driven by a
    CSV file (examples/aim.csv by default) that can be replaced at runtime
    via the “Load CSV” button.
  -->
    <title>AIM (Aspirational Identity Map)</title>
  <style>
    /* Basic reset and typography */
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
        Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      background: #ffffff;
      color: #333333;
    }
    #titleBar {
      font-size: 1.4rem;
      font-weight: 600;
      padding: 16px;
      border-bottom: 1px solid #e0e0e0;
    }
    /* Container flex layout */
    #container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
      padding: 12px;
      gap: 16px;
    }
    /* Chart wrapper grows to fill space */
    #chartWrapper {
      /* Allow the chart wrapper to take up all available horizontal space */
      flex: 1 1 0;
      min-width: 0;
      position: relative;
      /* Reserve vertical space so the chart isn’t constrained to a tiny area. The
         height will be further constrained by computeRadii() to fit within
         the viewport on desktop. */
      min-height: 480px;
    }
    svg#aimChart {
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Sidebar/legend area */
    #sidebar {
      width: 220px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }

    /* Tabs for switching between AIM and project views */
    #tabBar {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      margin-top: 8px;
  padding-left: 12px;
}
    .tabButton {
      padding: 6px 12px;
      border-radius: 20px;
      background: #eaf5f6;
      border: 1px solid #b7dfe1;
      cursor: pointer;
      font-size: 0.9rem;
      color: #2a4d55;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .tabButton.active {
      background: #ffffff;
      border-color: #88c6cb;
      font-weight: 600;
      color: #1d3940;
    }
    .tabButton:hover {
      background: #dff1f2;
    }

    /* Heatmap select styling */
    #heatmapSelect {
      font-size: 0.85rem;
      padding: 4px 6px;
      border: 1px solid #cccccc;
      border-radius: 4px;
    }
    button {
      padding: 6px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      border: 1px solid #cccccc;
      border-radius: 4px;
      background: #f9f9f9;
      box-shadow: 0 1px 2px rgba(0,0,0,0.06);
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover {
      background: #efefef;
      box-shadow: 0 1px 4px rgba(0,0,0,0.12);
    }

    /* Icon buttons for action controls */
    .iconButton {
      padding: 6px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #cccccc;
      border-radius: 4px;
      background: #f9f9f9;
      box-shadow: 0 1px 2px rgba(0,0,0,0.06);
      cursor: pointer;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }
    .iconButton:hover {
      background: #efefef;
      box-shadow: 0 1px 4px rgba(0,0,0,0.12);
    }
    #legend {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .legend-chip {
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      position: relative;
    }
    .legend-chip .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
      flex-shrink: 0;
    }
    .legend-chip:hover .dot,
    .legend-chip:focus-visible .dot {
      outline: 2px solid currentColor;
    }
    .legend-chip.selected .dot {
      border: 2px solid currentColor;
    }
    /* Tooltip styles */
    #tooltip {
      position: fixed;
      pointer-events: none;
      background: #ffffff;
      border-radius: 4px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.12), 0 2px 8px rgba(0,0,0,0.08);
      padding: 8px 10px;
      font-size: 12px;
      line-height: 1.3;
      z-index: 200;
      max-width: 240px;
      display: none;
      color: #111;
    }
    #tooltip .breadcrumb {
      font-size: 11px;
      color: #666;
      margin-top: 2px;
    }
    /* Overlay for the table view */
    #tableOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }
    #tableOverlay .tableContainer {
      background: #ffffff;
      border-radius: 6px;
      max-width: 90%;
      max-height: 90%;
      padding: 16px;
      overflow: auto;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }
    #tableOverlay table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    #tableOverlay th, #tableOverlay td {
      border: 1px solid #dddddd;
      padding: 6px 8px;
      vertical-align: top;
    }
    #tableOverlay th {
      background: #f5f5f5;
      font-weight: 600;
    }
    #tableOverlay tbody tr:nth-child(even) {
      background: #fcfcfc;
    }
    #tableOverlay input[type="search"] {
      width: 100%;
      padding: 6px;
      margin-bottom: 10px;
      border: 1px solid #cccccc;
      border-radius: 4px;
    }
    #closeTableBtn {
      margin-bottom: 8px;
    }
    /* Responsive adjustments */
    @media (max-width: 600px) {
      #container {
        flex-direction: column;
      }
      #sidebar {
        width: auto;
        margin-top: 20px;
      }
      #legend {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 12px;
      }
    }
    /* Focus ring for SVG arcs */
    .wedge:focus-visible {
      stroke: #000;
      stroke-width: 2px;
    }

    /* Remove default focus outline on SVG paths to avoid blue focus rectangles */
    svg .wedge:focus {
      outline: none;
    }
  
#projectsList .iconButton[title="Edit project"]{ display:none !important; }
</style>
</head>
<body>
  <header id="titleBar" style="display:flex; align-items:center; justify-content:space-between; gap:12px; padding-right:16px;">
    <span id="titleText">AIM</span>
    <div id="headerActions" style="display:flex; gap:8px; align-items:center;">
      <!-- Home button: navigate back to the core view without reloading data -->
      <button id="resetBtn" class="iconButton" aria-label="Home" title="Home">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M12 3l10 9h-3v9h-5v-6h-2v6H6v-9H3l9-9z" fill="currentColor"/>
        </svg>
      </button>
      <!-- Save button: downloads the current dataset as CSV -->
      <button id="saveBtn" class="iconButton" aria-label="Save" title="Save CSV">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M17 17H7v-2h10v2zm0-4H7V11h10v2zm0-4H7V7h10v2zm3-5H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM4 20V6h16v14H4z" fill="currentColor"/>
        </svg>
      </button>
      <!-- Upload button: up arrow with line -->
      <button id="uploadBtn" class="iconButton" aria-label="Upload CSV" title="Upload CSV">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M12 5l5 5h-3v6h-4v-6H7l5-5zm-7 14h14v2H5v-2z" fill="currentColor"/>
        </svg>
      </button>
      <!-- View data button: four squares -->
      <button id="viewTableBtn" class="iconButton" aria-label="View data" title="View data">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M3 3h7v7H3V3zm0 11h7v7H3v-7zm11-11h7v7h-7V3zm0 11h7v7h-7v-7z" fill="currentColor"/>
        </svg>
      </button>
    </div>
  </header>
  <!-- Tabs to switch between AIM and Projects views -->
  <div id="tabBar">
    <button id="aimTab" class="tabButton active" aria-label="Show AIM view">AIM</button>
    <button id="projectsTab" class="tabButton" aria-label="Show projects view">Projects</button>
  </div>
  <!-- AIM view wrapper -->
  <div id="aimView">
    <div id="container">
      <div id="chartWrapper">
      <!-- Chart SVG will be inserted here -->
      <svg id="aimChart" role="img" aria-label="Aspirational Identity Map"></svg>
    </div>
    <div id="sidebar">
      <div id="legend" aria-label="Pillar legend"></div>

      <!-- Heatmap selection -->
      <div id="heatmapToggleContainer" style="font-size:0.85rem; display:flex; flex-direction:column; align-items:flex-start; gap:4px; margin-top:8px; padding-bottom:8px; border-bottom:1px solid #e0e0e0;">
        <!-- Row for the heatmap label and info icon -->
        <div style="display:flex; align-items:center; gap:4px;">
          <label for="heatmapSelect" style="font-weight:600; margin:0;">Heatmap</label>
          <!-- Info icon: description updates based on selected type -->
          <span id="heatmapInfo" title="" style="display:inline-flex; align-items:center; justify-content:center; width:14px; height:14px; border-radius:50%; border:1px solid #999; font-size:10px; cursor:default; line-height:14px;">i</span>
        </div>
        <!-- Heatmap select on its own line beneath the label -->
        <select id="heatmapSelect" aria-label="Select heatmap type" style="margin-left:0; margin-top:2px;">
          <option value="off">Off</option>
          <option value="confidence">Alignment</option>
          <option value="ac">Adaptive challenge</option>
          <option value="ce">Celebration</option>
          <option value="cx">Collective experience</option>
        </select>
        <!-- Legend / key for the heatmap. Updated dynamically based on selected type. -->
        <div id="heatmapLegend" style="font-size:0.75rem; line-height:1.2; margin-top:4px; margin-left:0; max-width:220px;"></div>
      </div>

      <!-- Action buttons moved to header: hide sidebar copy -->
      <div id="actionButtons" style="display:none;">
        <!-- Icon-only buttons with tooltips -->
        <!-- Reset button: large circular arrow -->
        <button id="resetBtn" class="iconButton" aria-label="Reload map" title="Reload map">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <!-- Simplified circular reload arrow icon for better recognisability -->
            <path d="M12 4V1L6 7l6 6V8a6 6 0 1 1-6 6H5a7 7 0 1 0 7-7z" fill="currentColor"/>
          </svg>
        </button>
        <!-- Upload button: up arrow with line -->
        <button id="uploadBtn" class="iconButton" aria-label="Upload CSV" title="Upload CSV">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 5l5 5h-3v6h-4v-6H7l5-5zm-7 14h14v2H5v-2z" fill="currentColor"/>
          </svg>
        </button>
        <!-- View data button: grid icon -->
        <button id="viewTableBtn" class="iconButton" aria-label="View data" title="View data">
          <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M3 3h7v7H3V3zm0 11h7v7H3v-7zm11-11h7v7h-7V3zm0 11h7v7h-7v-7z" fill="currentColor"/>
          </svg>
        </button>
      </div>

      <!-- Lenses block -->
      <div id="lensesBlock" style="margin-top:12px; max-width:200px;" aria-label="Lenses section">
        <!-- Dynamic heading for the lenses list.  Includes an info icon with a definition on hover.  -->
        <div style="display:flex; align-items:center; gap:4px; font-weight:600; margin-bottom:4px;">
          <span id="lensesTitle">Lenses</span>
          <span id="lensesInfo" title="A Lens is an enjoyable entry point you feel drawn to—activities or contexts that make it easy to show up." style="display:inline-flex; align-items:center; justify-content:center; width:14px; height:14px; border-radius:50%; border:1px solid #999; font-size:10px; cursor:default; line-height:14px;">i</span>
        </div>
        <div id="lensesList" style="font-size:0.85rem; color:#333;">No lenses</div>
      </div>
    <input type="file" id="csvFileInput" accept=".csv" style="display:none" aria-label="CSV file input">
    </div> <!-- end sidebar -->
    </div> <!-- end container -->
  </div> <!-- end aimView -->
  <!-- Projects view: hidden by default -->
  <div id="projectsView" style="display:none; padding:16px;">
    <h2 style="margin-top:0; font-size:1.2rem; font-weight:600;">Projects</h2>
    <!-- Action buttons duplicated for projects view -->
    <div id="projectsButtons" style="display:none;">
      <!-- Reset map (projects) reuses the same functionality -->
      <button id="resetBtnProjects" class="iconButton" aria-label="Reload map" title="Reload map">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M12 4V1L6 7l6 6V8a6 6 0 1 1-6 6H5a7 7 0 1 0 7-7z" fill="currentColor"/>
        </svg>
      </button>
      <!-- Upload CSV for projects view -->
      <button id="uploadBtnProjects" class="iconButton" aria-label="Upload CSV" title="Upload CSV">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M12 5l5 5h-3v6h-4v-6H7l5-5zm-7 14h14v2H5v-2z" fill="currentColor"/>
        </svg>
      </button>
      <!-- View data for projects view -->
      <button id="viewTableBtnProjects" class="iconButton" aria-label="View data" title="View data">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <path d="M3 3h7v7H3V3zm0 11h7v7H3v-7zm11-11h7v7h-7V3zm0 11h7v7h-7v-7z" fill="currentColor"/>
        </svg>
      </button>
    </div>
    <div id="projectsList" style="display:flex; flex-direction:column; gap:12px;"></div>
    <!-- Button to show additional projects.  A margin is added to separate it from the list below. -->
    <button id="showMoreProjectsBtn" style="display:none; padding:6px 12px; font-size:0.85rem; border:1px solid #ccc; border-radius:4px; background:#f5f5f5; cursor:pointer; margin-top:12px;">Show more</button>
    <button id="showLessProjectsBtn" style="display:none; padding:6px 12px; font-size:0.85rem; border:1px solid #ccc; border-radius:4px; background:#f5f5f5; cursor:pointer; margin-top:4px;">Show less</button>
  </div>
  <div id="tooltip" role="tooltip" aria-hidden="true"></div>
  <div id="tableOverlay" role="dialog" aria-modal="true" aria-label="AIM table view">
    <div class="tableContainer">
      <button id="closeTableBtn" aria-label="Close table view">Close</button>
      <!-- Editable title for the AIM map -->
      <div style="margin: 6px 0; display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
        <label for="editTitleInput" style="font-size:0.85rem;">Name:</label>
        <input type="text" id="editTitleInput" placeholder="Enter map name" style="flex:1; min-width:150px; padding:4px; font-size:0.85rem; border:1px solid #ccc; border-radius:4px;">
        <!-- Download CSV: icon-only button inside overlay -->
        <button id="downloadCsvBtn" class="iconButton" aria-label="Save CSV" title="Save CSV">
          <!-- Down arrow icon with line -->
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M12 2v14m0 0l-5-5m5 5l5-5M5 20h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
          </svg>
        </button>
        <!-- Edit data button: pencil icon -->
        <button id="editDataBtn" class="iconButton" aria-label="Edit data" title="Edit data">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" fill="currentColor"/>
          </svg>
        </button>
      </div>
      <!-- Filter and search row: show the filter select and search input on one line -->
      <div style="margin-bottom:6px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
        <select id="tableFilterSelect" style="padding:4px; font-size:0.85rem; border:1px solid #ccc; border-radius:4px;">
          <option value="all">All entries</option>
        </select>
        <input type="search" id="tableSearch" placeholder="Search title or belief…" aria-label="Search titles or beliefs" style="flex:1; min-width:150px; padding:4px; font-size:0.85rem; border:1px solid #ccc; border-radius:4px;">
      </div>

      <!-- Note shown when editing is enabled -->
      <div id="editNote" style="display:none; font-size:0.75rem; color:#666; margin-bottom:6px;">
        Changes will only persist for this session. Download the CSV to save your edits.
      </div>
      <!-- Tab bar for switching between AIM and Projects in the data view -->
      <div id="dataTabBar" style="display:flex; gap:8px; margin:6px 0;">
        <button id="dataTabAimBtn" class="tabButton active" aria-label="Show AIM data">Beliefs</button>
        <button id="dataTabProjectsBtn" class="tabButton" aria-label="Show projects data">Projects</button>
      </div>
      <!-- Table for AIM nodes (beliefs and lenses) -->
      <table id="nodeTable">
        <thead>
        <tr><th>Depth</th><th>Pillar</th><th>Sub</th><th>Micro</th><th>Title</th><th>Belief</th><th>Confidence</th><th>Last updated</th><th>Adaptive</th><th>Celebration</th><th>Collective experience</th><th>Applies to</th><th>Today</th><th>Details</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <!-- Table for Projects (hidden by default) -->
      <table id="projectsTable" style="display:none; margin-top:8px;">
        <thead>
          <tr><th>Name</th><th>Type</th><th>Measure</th><th>Start</th><th>Target</th><th>Days/week</th><th>Duration</th><th>Benefit</th><th>Today</th><th>Details</th><th>Priority (user)</th><th>Priority (AI)</th><th>Outcome</th><th>Acceptance</th><th>Reference</th><th>Pillar</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <!-- D3 library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  // Wrap all variables inside an IIFE to avoid polluting the global scope
  (function() {
    // Character limits for truncating belief text by depth.  These values
    // determine how many characters are kept before adding an ellipsis.  We
    // deliberately allow more characters than before so truncated labels are
    // longer but still fit within their wedges.  Depth 1 (pillars) has the
    // highest allowance, depth 2 (subs) is moderate, and depth 3 (micros) is
    // shorter.  Centre/pillar/sub beliefs use a separate limit below.
    // Maximum number of characters to display in labels for each depth.  These
    // values are intentionally conservative to reduce overflow: depth 1 (pillars)
    // gets 45 characters, depth 2 (subs) gets 35 and depth 3 (micros) gets 25.
    const maxCharsByDepth = {1: 45, 2: 35, 3: 25};

    // Maximum characters for centre and legend beliefs.  These apply when
    // displaying the belief in the centre of the chart or the outer ring of
    // three (pillars, subs or micros).  Truncating with an ellipsis keeps
    // the visible text concise; hovering reveals the full belief via tooltip.
    // Maximum characters allowed in the centre belief (core/pillar/sub).  A
    // lower limit reduces overflow in the core view.  Full text remains
    // accessible via the tooltip.
    // Maximum characters for centre beliefs (core/pillar/sub) when displayed in the
    // centre of the chart.  Increase this limit slightly to show more of the
    // belief text in the centre view.  Titles are not used in the centre; we
    // always display truncated belief text here.
    // Allow more characters for the belief shown in the centre of the chart.
    // This value is used to truncate the core/pillar/sub beliefs when they
    // appear in the centre.  Increase the limit to show more of the
    // underlying belief text while still fitting within the available space.
    const centerBeliefMaxChars = 120;

    // Additional gap between lines in the centre text.  Increasing this
    // value adds more space between the title and the belief text for better
    // readability.  Used by drawCenterText to separate lines vertically.
    const centerLineGap = 4;
    // Base RGB colours for the three pillars
    const pillarBases = [
      [42, 161, 152],    // teal
      [94, 92, 230],     // indigo/lavender
      [255, 138, 61]     // orange
    ];
    // Alpha values by depth (1: pillars, 2: subs, 3: micros)
    const depthAlpha = {1: 0.25, 2: 0.20, 3: 0.18};

    // Alignment categories mapping numeric values (0–100) into descriptive
    // buckets for user‑friendly display.  Each category has a label and an
    // inclusive numeric range.  Modify these ranges to tune the grouping.
    const alignmentCategories = [
      { label: 'Low alignment', min: 0, max: 39 },
      { label: 'Moderate alignment', min: 40, max: 69 },
      { label: 'High alignment', min: 70, max: 89 },
      { label: 'Very high alignment', min: 90, max: 100 }
    ];

    /**
     * Maps a numeric alignment/confidence value to a categorical label.
     * @param {number} val Numeric value 0–100
     * @returns {string} Category label
     */
    function getAlignmentLabel(val) {
      if (typeof val !== 'number' || isNaN(val)) return '';
      const v = Math.max(0, Math.min(100, val));
      for (const cat of alignmentCategories) {
        if (v >= cat.min && v <= cat.max) return cat.label;
      }
      return '';
    }

    /**
     * Formats a date/time string into 'MMM DD, YYYY' using US locale.  If the
     * input cannot be parsed as a date, returns an empty string.
     * @param {string} str ISO or other date/time string
     * @returns {string} Formatted date or empty string
     */
    function formatDateString(str) {
      if (!str) return '';
      const date = new Date(str);
      if (isNaN(date)) return '';
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    }

    /**
     * Returns a descriptive phrase for a segmentation pole value.
     * The value is expected to be an integer from -3 to +3 and the
     * letter indicates which side is considered positive.  A positive
     * value means the orientation equals the provided letter; a negative
     * value means the opposite orientation.  A zero value yields
     * "balanced".  The wording follows these rules:
     *  ±1 → "leans …";
     *  ±2 → "strong … tilt";
     *  ±3 → "is very … oriented".
     * @param {number|null} val Numeric value −3..+3 (null if missing)
     * @param {string|null} letter The right-side letter (C,G,D,P,A,S)
     * @param {string} type Pole type: 'ac','ce','cx'
     * @returns {string} Human-friendly description or empty string if not applicable
     */
    function getPolePhrase(val, letter, type) {
      // Returns a human‑friendly phrase describing the orientation strength and direction for
      // a given segmentation pole.  The `val` is an integer from –3 to +3, where the
      // sign indicates which side of the pole the belief leans toward and the
      // magnitude indicates how strong the leaning is.  The `letter` identifies the
      // original orientation letter (e.g., C or G for adaptive challenge).  When
      // val is 0, the belief is balanced between the two poles.  For non‑zero
      // values, we compute the appropriate orientation name (Constant, Guided,
      // Destination, Practice, Asynchronous, Synchronized) and return a phrase
      // like “leans Constant”, “strong Guided tilt”, or “is very Destination oriented”.
      if (val === null || val === undefined || letter === null || !type) return '';
      const names = {
        ac: { C: 'Constant', G: 'Guided' },
        ce: { D: 'Destination', P: 'Practice' },
        cx: { A: 'Asynchronous', S: 'Synchronized' }
      };
      const opposites = {
        ac: { C: 'G', G: 'C' },
        ce: { D: 'P', P: 'D' },
        cx: { A: 'S', S: 'A' }
      };
      const poleNames = names[type] || {};
      const oppositeMap = opposites[type] || {};
      let orientationLetter;
      if (val > 0) {
        // Positive values use the provided orientation letter
        orientationLetter = letter.toUpperCase();
      } else if (val < 0) {
        // Negative values invert the orientation letter to the opposite side
        orientationLetter = oppositeMap[letter.toUpperCase()] || letter.toUpperCase();
      } else {
        return 'balanced';
      }
      const orientationName = poleNames[orientationLetter] || '';
      const abs = Math.abs(val);
      let phrase;
      if (abs === 1) {
        // Mild leaning
        phrase = 'leans ' + orientationName;
      } else if (abs === 2) {
        // Strong leaning
        phrase = 'strong ' + orientationName + ' tilt';
      } else if (abs === 3) {
        // Very strong leaning
        phrase = 'is very ' + orientationName + ' oriented';
      } else {
        phrase = '';
      }
      return phrase;
    }
    // Data model for the current AIM dataset
    let aimData = null;
    // Current visual state: 'A' (global), 'B' (pillar focus), 'C' (sub focus)
    let currentState = 'A';
    let selectedPillar = null;   // integer 1..3 when in B or C
    let selectedSub = null;      // integer 1..3 when in C
    let preselectedSub = null;   // used when entering B from a sub click

    // Whether to display the confidence heatmap overlay.  When set to true
    // the base pillar colours are blended with a hue based on each belief’s
    // confidence (0–100).  This is controlled via the "Show confidence
    // heatmap" checkbox in the sidebar.
    // Heatmap mode: 'off', 'confidence', 'ac', 'ce', 'cx'.  Determines which
    // metric is used to colour the wedges.  'off' disables the heatmap.
    let heatmapType = 'off';

    /**
     * Blending coefficient for the confidence heatmap.  When the heatmap is
     * enabled, the pillar’s base colour is blended with a heat colour
     * representing the confidence value.  A higher coefficient emphasises
     * differences in confidence.  We set this to 1.0 (100% heat) so
     * confidence values dominate the colour and remain visible.
     */
    const heatBlendRatio = 1.0;

    /**
     * Computes a heat colour from a confidence value in the range 0–100.
     * The hue transitions linearly from red (low confidence) at 0° through
     * yellow at 60° to green at 120°.  Saturation and lightness are fixed
     * to preserve contrast with the base palette.  Returns an array of
     * [r,g,b] values on a 0–255 scale.
     *
     * @param {number} conf Confidence value (0–100)
     * @returns {number[]} Array [r,g,b] colour components
     */
    function computeHeatColor(conf) {
      const ratio = Math.max(0, Math.min(100, conf)) / 100;
      const hue = 120 * ratio; // 0 (red) to 120 (green)
      // Increase saturation and slightly darken the heat colour so that
      // confidence differences are more pronounced on a white background.  A
      // saturation of 0.65 and lightness of 0.45 produce deeper reds and greens.
      const hslColor = d3.hsl(hue, 0.65, 0.45);
      const rgb = hslColor.rgb();
      return [Math.round(rgb.r), Math.round(rgb.g), Math.round(rgb.b)];
    }

    /**
     * Determines the fill colour for a wedge descriptor.  When the
     * confidence heatmap is disabled, this simply applies the pillar’s base
     * RGB with a depth‑specific alpha.  When enabled, the base colour is
     * blended 50/50 with a heat colour derived from the belief’s
     * confidence value.  The alpha remains tied to the depth as per the
     * original specification.
     *
     * @param {Object} descriptor The wedge descriptor containing pillar,
     *     depth and confidence properties
     * @returns {string} CSS rgba colour string
     */
    function computeFillColor(descriptor) {
      const base = pillarBases[descriptor.pillar - 1];
      const alpha = depthAlpha[descriptor.depth];
      // No heatmap selected: return base colour with depth alpha
      if (!heatmapType || heatmapType === 'off') {
        return `rgba(${base[0]},${base[1]},${base[2]},${alpha})`;
      }
      // Determine value for heatmap: use different properties based on mode
      let val;
      if (heatmapType === 'confidence') {
        val = (descriptor.confidence !== undefined) ? descriptor.confidence : 50;
        // clamp to 0–100
        val = Math.max(0, Math.min(100, val));
      } else if (heatmapType === 'ac') {
        // Adaptive Challenge: map value (-3..3) to 0–100
        const v = (descriptor.pole_ac_value !== null && descriptor.pole_ac_value !== undefined) ? descriptor.pole_ac_value : 0;
        val = ((v + 3) / 6) * 100;
      } else if (heatmapType === 'ce') {
        // Celebration pole
        const v = (descriptor.pole_ce_value !== null && descriptor.pole_ce_value !== undefined) ? descriptor.pole_ce_value : 0;
        val = ((v + 3) / 6) * 100;
      } else if (heatmapType === 'cx') {
        // Collective Experience pole
        const v = (descriptor.pole_cx_value !== null && descriptor.pole_cx_value !== undefined) ? descriptor.pole_cx_value : 0;
        val = ((v + 3) / 6) * 100;
      } else {
        val = 50;
      }
      const heat = computeHeatColor(val);
      return `rgba(${heat[0]},${heat[1]},${heat[2]},${alpha})`;
    }

    // Cached DOM selections
    const svg = d3.select('#aimChart');
    const tooltip = d3.select('#tooltip');
    const legendContainer = d3.select('#legend');
    const titleBar = d3.select('#titleBar');

    // Setup file input for CSV loading
    const fileInput = document.getElementById('csvFileInput');
    // Bind upload CSV button (inside the table overlay) to trigger the hidden file input
    // Upload button in the sidebar (up arrow icon)
    const uploadBtn = document.getElementById('uploadBtn');
    if (uploadBtn) {
      uploadBtn.addEventListener('click', () => {
        if (fileInput) fileInput.click();
      });
    }
    if (fileInput) {
      fileInput.addEventListener('change', handleFileUpload);
    }

    // Home button: return to the global view without reloading data.  Clicking
    // this button resets the visual state to show the core and all pillars
    // but preserves any edits or loaded dataset.  It does not clear
    // alignment or heatmap settings.
    document.getElementById('resetBtn').addEventListener('click', () => {
      // Reset state variables
      currentState = 'A';
      selectedPillar = null;
      selectedSub = null;
      preselectedSub = null;
      // Re-render chart, legend and lenses to reflect the global view
      updateChart();
      updateLegend();
      updateLenses();
      updateHeatmapLegend();
    });

    // Table view controls
    const tableOverlay = document.getElementById('tableOverlay');
    const tableBody = document.querySelector('#nodeTable tbody');
  const projectsTableBody = document.querySelector('#projectsTable tbody');
    const closeTableBtn = document.getElementById('closeTableBtn');
    const viewTableBtn = document.getElementById('viewTableBtn');
    const tableSearchInput = document.getElementById('tableSearch');
    const editTitleInput = document.getElementById('editTitleInput');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
  // Save button in header
  const saveBtn = document.getElementById('saveBtn');
  const editDataBtn = document.getElementById('editDataBtn');
  const editNote = document.getElementById('editNote');
  // Duplicate action buttons for projects view
  const resetBtnProjects = document.getElementById('resetBtnProjects');
  const uploadBtnProjects = document.getElementById('uploadBtnProjects');
  const viewTableBtnProjects = document.getElementById('viewTableBtnProjects');

  // Data tab elements for switching between AIM (beliefs) and Projects views in the data overlay
  const dataTabAimBtn = document.getElementById('dataTabAimBtn');
  const dataTabProjectsBtn = document.getElementById('dataTabProjectsBtn');
  const nodeTable = document.getElementById('nodeTable');
  const projectsTable = document.getElementById('projectsTable');

  // Keep track of which data table is active in the overlay ('aim' or 'projects')
  let currentDataTab = 'aim';

  /**
   * Shows the requested data tab ('aim' for beliefs/lenses or 'projects' for project data).
   * Updates the active styling on the tab buttons, toggles the visibility of
   * the corresponding table and search/filter controls, and rebuilds the
   * relevant table view when switching.  The search box is shared; it
   * always searches within the currently visible table.
   * @param {string} tab - 'aim' or 'projects'
   */
  function showDataTab(tab) {
    currentDataTab = tab;
    // Update active classes on tab buttons
    if (dataTabAimBtn) dataTabAimBtn.classList.toggle('active', tab === 'aim');
    if (dataTabProjectsBtn) dataTabProjectsBtn.classList.toggle('active', tab === 'projects');
    // Toggle tables
    if (nodeTable) nodeTable.style.display = (tab === 'aim') ? '' : 'none';
    if (projectsTable) projectsTable.style.display = (tab === 'projects') ? '' : 'none';
    // Keep the filter select visible regardless of tab.  Filtering applies
    // primarily to beliefs; projects ignore the filter but keep the control
    // visible for consistency.
    // Rebuild the appropriate table view
    if (tab === 'aim') {
      buildTableView();
    } else {
      buildProjectsTableView();
    }
  }

  /**
   * Builds the projects table view.  Iterates over aimData.projects and
   * populates rows with human‑friendly column names.  Allows editing of
   * free‑text fields when editingEnabled is true.  Numerical values are
   * treated as text for editing purposes.  Changes persist only in the
   * current session until the user downloads the CSV.
   */
  function buildProjectsTableView() {
    if (!aimData) return;
    if (!projectsTableBody) return;
    projectsTableBody.innerHTML = '';
    // If no projects, display a single row with message
    if (!aimData.projects || aimData.projects.length === 0) {
      const tr = document.createElement('tr');
      // Assign dataset attributes: projectIndex and pillar name for filtering
      tr.dataset.projectIndex = idx;
      if (proj.pillar && aimData.pillarNames[proj.pillar]) {
        tr.dataset.pillar = aimData.pillarNames[proj.pillar];
      }
      const td = document.createElement('td');
      td.colSpan = 14;
      td.textContent = 'No projects defined.';
      tr.appendChild(td);
      projectsTableBody.appendChild(tr);
      return;
    }
    // Build rows for projects
    aimData.projects.forEach((proj, idx) => {
      const tr = document.createElement('tr');
      // Assign dataset attributes for editing and filtering.  projectIndex is used to highlight rows when editing
      tr.dataset.projectIndex = idx;
      // Set pillar name for filtering if available
      if (proj.pillar && aimData.pillarNames[proj.pillar]) {
        tr.dataset.pillar = aimData.pillarNames[proj.pillar];
      }
      // Determine pillar name for display if available
      let pillarName = '';
      if (proj.pillar && aimData.pillarNames[proj.pillar]) {
        pillarName = aimData.pillarNames[proj.pillar];
      }
      // Helper to assign cell content and editing behaviour
      function createCell(value, onBlur, editable) {
        const td = document.createElement('td');
        td.textContent = value || '';
        if (editingEnabled && editable) {
          td.contentEditable = true;
          td.style.backgroundColor = '#fff8e1';
          td.addEventListener('blur', onBlur);
        }
        return td;
      }
      // Name (project action or fallback to outcome/title/belief)
      const nameVal = proj.action || proj.outcome || proj.benefit || '(Unnamed project)';
      tr.appendChild(createCell(nameVal, () => {
        const newVal = tr.children[0].textContent.trim();
        proj.action = newVal;
        buildProjectsTableView();
        updateProjectsView();
      }, true));
      
// Type (Practice or Sprint) — dropdown when editing is enabled
(function(){
  const td = document.createElement('td');
  if (editingEnabled) {
    const select = document.createElement('select');
    const opts = ['Practice','Sprint'];
    opts.forEach(lbl => {
      const opt = document.createElement('option');
      opt.value = lbl.toLowerCase();
      opt.textContent = lbl;
      select.appendChild(opt);
    });
    select.value = (proj.type || '').toLowerCase() === 'sprint' ? 'sprint' : 'practice';
    select.addEventListener('change', () => {
      proj.type = select.value;
      buildProjectsTableView();
      updateProjectsView();
    });
    td.appendChild(select);
    td.style.backgroundColor = '#fff8e1';
  } else {
    td.textContent = (proj.type || '').toLowerCase() === 'sprint' ? 'Sprint' : (proj.type ? 'Practice' : '');
  }
  tr.appendChild(td);
})();
const isSprintRow = (proj.type || '').toLowerCase() === 'sprint';

      // Measure
      tr.appendChild(createCell(isSprintRow ? '' : (proj.measure || ''), () => {
        proj.measure = tr.children[2].textContent.trim();
      }, !isSprintRow));
      // Start (treat as string for editing)
      tr.appendChild(createCell(isSprintRow ? '' : ((proj.start !== null && proj.start !== undefined) ? String(proj.start) : ''), () => {
        const val = tr.children[3].textContent.trim();
        proj.start = val;
      }, !isSprintRow));
      // Target
      tr.appendChild(createCell(isSprintRow ? '' : ((proj.target !== null && proj.target !== undefined) ? String(proj.target) : ''), () => {
        proj.target = tr.children[4].textContent.trim();
      }, !isSprintRow));
      // Days/week
      tr.appendChild(createCell(isSprintRow ? '' : ((proj.days !== null && proj.days !== undefined) ? String(proj.days) : ''), () => {
        proj.days = tr.children[5].textContent.trim();
      }, !isSprintRow));
      // Duration (only for sprint)
      tr.appendChild(createCell(isSprintRow ? (proj.duration || '') : '', () => {
        const val = tr.children[6].textContent.trim();
        proj.duration = val;
      }, isSprintRow));
      // Benefit
      tr.appendChild(createCell(proj.benefit || '', () => {
        proj.benefit = tr.children[7].textContent.trim();
      }, true));
      // Today
      tr.appendChild(createCell(proj.today_state || '', () => {
        proj.today_state = tr.children[8].textContent.trim();
      }, true));
      // Details
      tr.appendChild(createCell(proj.details || '', () => {
        proj.details = tr.children[9].textContent.trim();
      }, true));
      // Priority (user)
      tr.appendChild(createCell(proj.priority_user || '', () => {
        proj.priority_user = tr.children[10].textContent.trim();
        // Resort projects after editing priority
        buildProjectsTableView();
        updateProjectsView();
      }, true));
      // Priority (AI)
      tr.appendChild(createCell(proj.priority_ai || '', () => {
        proj.priority_ai = tr.children[11].textContent.trim();
      }, true));
      // Outcome
      tr.appendChild(createCell(proj.outcome || '', () => {
        proj.outcome = tr.children[12].textContent.trim();
      }, true));
      // Acceptance
      tr.appendChild(createCell(proj.acceptance || '', () => {
        proj.acceptance = tr.children[13].textContent.trim();
      }, true));
      // Reference
      tr.appendChild(createCell(proj.ref || '', () => {
        proj.ref = tr.children[14].textContent.trim();
      }, true));
      // Pillar
      tr.appendChild(createCell(pillarName, null, false));
      projectsTableBody.appendChild(tr);
    });
  }

  // Flag to indicate whether editing mode is enabled.  When true, table
  // cells become editable and the Applies column uses a multi‑select for
  // lenses.  Edits persist only during the current session.
  let editingEnabled = false;

    // Heatmap selection handler.  Update the heatmapType and re-render chart and lenses.
    const heatmapSelect = document.getElementById('heatmapSelect');
    const heatmapInfoEl = document.getElementById('heatmapInfo');
    /**
     * Updates the tooltip on the heatmap info icon based on the selected
     * heatmap type.  Provides a concise description of what the colours
     * represent for each metric.  Called whenever the heatmap selection
     * changes.
     */
    function updateHeatmapInfo() {
      if (!heatmapInfoEl) return;
      let desc = '';
      switch (heatmapType) {
        case 'confidence':
          desc = 'Alignment heatmap: red = low alignment; green = high alignment. Based on how recently and frequently you mention a topic.';
          break;
        case 'ac':
          desc = 'Adaptive challenge: red = Constant; green = Guided.';
          break;
        case 'ce':
          desc = 'Celebration: red = Destination; green = Practice.';
          break;
        case 'cx':
          desc = 'Collective experience: red = Asynchronous; green = Synchronized.';
          break;
        default:
          desc = 'No heatmap overlay.';
      }
      heatmapInfoEl.title = desc;
    }

    /**
     * Updates the visual legend for the current heatmap type.  When a
     * heatmap is selected, the legend displays a simple colour bar
     * illustrating the mapping from red (left) to green (right) along with
     * the orientation names on each end.  A small info icon on the right
     * of each label provides a tooltip definition for that orientation.
     */
    function updateHeatmapLegend() {
      const legendEl = document.getElementById('heatmapLegend');
      if (!legendEl) return;
      // Clear existing content
      legendEl.innerHTML = '';
      // Ensure the legend element stretches across its container so
      // orientation names can justify space between left and right.  Without
      // explicitly setting a width, the legend container may shrink to fit
      // its contents, causing the names to run together.
      legendEl.style.width = '100%';
      // Helper to create a gradient bar with labels and definitions.  Accepts flags
      // showDefs and showSwatches to control whether the definitions row is
      // displayed and whether coloured swatches accompany definitions.  This
      // allows alignment and pole legends to omit squares and redundant
      // orientation names.
      function createLegend(leftName, rightName, leftDef, rightDef, showDefs = true, showSwatches = true) {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.flexDirection = 'column';
        wrapper.style.gap = '3px';
        // Ensure the legend uses the full available width so names separate properly
        wrapper.style.width = '100%';
        // Gradient bar illustrating colour range from red (left) to green (right)
        const bar = document.createElement('div');
        bar.style.height = '6px';
        bar.style.borderRadius = '3px';
        bar.style.background = 'linear-gradient(90deg, #e74c3c 0%, #e67e22 30%, #f1c40f 60%, #2ecc71 100%)';
        bar.style.width = '100%';
        wrapper.appendChild(bar);
        // Row of orientation names with tooltips; bold font emphasises the pole names
        const namesRow = document.createElement('div');
        namesRow.style.display = 'flex';
        namesRow.style.justifyContent = 'space-between';
        namesRow.style.fontSize = '0.75rem';
        namesRow.style.fontWeight = '600';
        namesRow.style.color = '#333';
        namesRow.style.width = '100%';
        const leftNameSpan = document.createElement('span');
        leftNameSpan.textContent = leftName;
        leftNameSpan.title = leftDef;
        leftNameSpan.style.cursor = 'help';
        const rightNameSpan = document.createElement('span');
        rightNameSpan.textContent = rightName;
        rightNameSpan.title = rightDef;
        rightNameSpan.style.cursor = 'help';
        rightNameSpan.style.textAlign = 'right';
        namesRow.appendChild(leftNameSpan);
        namesRow.appendChild(rightNameSpan);
        wrapper.appendChild(namesRow);
        // Optional definitions row
        if (showDefs) {
          const defsRow = document.createElement('div');
          defsRow.style.display = 'flex';
          defsRow.style.justifyContent = 'space-between';
          defsRow.style.fontSize = '0.7rem';
          defsRow.style.color = '#555';
          // Left definition cell
          const leftCell = document.createElement('div');
          leftCell.style.display = 'flex';
          leftCell.style.alignItems = 'center';
          leftCell.style.gap = '4px';
          if (showSwatches) {
            const leftSwatch = document.createElement('span');
            leftSwatch.style.display = 'inline-block';
            leftSwatch.style.width = '10px';
            leftSwatch.style.height = '10px';
            leftSwatch.style.borderRadius = '2px';
            leftSwatch.style.background = '#e74c3c';
            leftCell.appendChild(leftSwatch);
          }
          const leftDefSpan = document.createElement('span');
          leftDefSpan.textContent = leftDef;
          leftDefSpan.style.flex = '1';
          leftCell.appendChild(leftDefSpan);
          // Right definition cell
          const rightCell = document.createElement('div');
          rightCell.style.display = 'flex';
          rightCell.style.alignItems = 'center';
          rightCell.style.gap = '4px';
          rightCell.style.justifyContent = 'flex-end';
          const rightDefSpan = document.createElement('span');
          rightDefSpan.textContent = rightDef;
          rightDefSpan.style.textAlign = 'right';
          rightDefSpan.style.flex = '1';
          if (showSwatches) {
            const rightSwatch = document.createElement('span');
            rightSwatch.style.display = 'inline-block';
            rightSwatch.style.width = '10px';
            rightSwatch.style.height = '10px';
            rightSwatch.style.borderRadius = '2px';
            rightSwatch.style.background = '#2ecc71';
            rightCell.appendChild(rightSwatch);
          }
          rightCell.appendChild(rightDefSpan);
          defsRow.appendChild(leftCell);
          defsRow.appendChild(rightCell);
          wrapper.appendChild(defsRow);
        }
        return wrapper;
      }
      // Determine legend based on heatmap type
      switch (heatmapType) {
        case 'confidence':
          // Alignment heatmap: show bar with Low/High names, no definitions row.  Add a
          // simple explanatory sentence beneath the bar to help users understand
          // how alignment is inferred.
          legendEl.appendChild(createLegend('Low', 'High', '', '', false, false));
          {
            const expl = document.createElement('div');
            expl.style.fontSize = '0.7rem';
            expl.style.color = '#555';
            expl.style.marginTop = '4px';
            expl.textContent = 'Alignment reflects how recently and frequently you’ve mentioned a topic—higher scores mean stronger alignment with your current wishes.';
            legendEl.appendChild(expl);
          }
          break;
        case 'ac':
          // Adaptive challenge: bar with names and definitions without squares.  Definitions omit the
          // orientation names because they are redundant — the pole names appear in the row above.
          legendEl.appendChild(createLegend(
            'Constant',
            'Guided',
            'Uses a fixed system shared by many and involves doing the same amount each time.',
            'Personalised experience fitting overall status and changing micro needs.',
            true,
            false
          ));
          break;
        case 'ce':
          // Celebration: bar with names and definitions without squares and without redundant pole names
          legendEl.appendChild(createLegend(
            'Destination',
            'Practice',
            'Revolves around reaching a specific end result or milestone.',
            'Is woven into the ongoing practice and process.',
            true,
            false
          ));
          break;
        case 'cx':
          // Collective experience: bar with names and definitions without squares and without redundant pole names
          legendEl.appendChild(createLegend(
            'Asynchronous',
            'Synchronized',
            'Activities are mostly independent with no regular shared schedule or group.',
            'Part of a collective experience with shared rhythm and support.',
            true,
            false
          ));
          break;
        default:
          legendEl.textContent = '';
      }
    }
    if (heatmapSelect) {
      heatmapSelect.addEventListener('change', () => {
        heatmapType = heatmapSelect.value || 'off';
        updateChart();
        updateLenses();
        updateHeatmapInfo();
        updateHeatmapLegend();
      });
      // Initialise heatmap info when page loads
      heatmapType = heatmapSelect.value || 'off';
      updateHeatmapInfo();
      updateHeatmapLegend();
    }

    viewTableBtn.addEventListener('click', () => {
      // Determine which tab is active on the main page to decide default data view
      const aimTabBtn = document.getElementById('aimTab');
      const projectsTabBtn = document.getElementById('projectsTab');
      let defaultTab = 'aim';
      if (projectsTabBtn && projectsTabBtn.classList.contains('active')) {
        defaultTab = 'projects';
      }
      // Show the overlay and appropriate table
      tableOverlay.style.display = 'flex';
      // Show data tab based on context; this calls buildTableView or buildProjectsTableView internally
      showDataTab(defaultTab);
      tableSearchInput.value = '';
      filterTable('');
      // Populate the editable title input with current map name
      if (editTitleInput) {
        editTitleInput.value = aimData && aimData.title ? aimData.title : '';
      }
    });
    closeTableBtn.addEventListener('click', () => {
      tableOverlay.style.display = 'none';
    });
    tableSearchInput.addEventListener('input', () => {
      filterTable(tableSearchInput.value.trim().toLowerCase());
    });

    // Data tab click handlers: switch between AIM (beliefs/lenses) and Projects
    if (dataTabAimBtn) {
      dataTabAimBtn.addEventListener('click', () => {
        showDataTab('aim');
        if (tableSearchInput) tableSearchInput.value = '';
        filterTable('');
      });
    }
    if (dataTabProjectsBtn) {
      dataTabProjectsBtn.addEventListener('click', () => {
        showDataTab('projects');
        if (tableSearchInput) tableSearchInput.value = '';
        // For projects, no filtering logic yet; reuse filterTable to reset search results
        filterTable('');
      });
    }

    // Toggle editing mode when the edit button is clicked.  Editing is
    // session‑only; changes are not saved back to the CSV unless the user
    // downloads the file.  Display a note when editing is enabled.
    if (editDataBtn) {
      editDataBtn.addEventListener('click', () => {
        editingEnabled = !editingEnabled;
        // Indicate active state on the button by changing background
        if (editingEnabled) {
          editDataBtn.style.backgroundColor = '#e6f5ff';
        } else {
          editDataBtn.style.backgroundColor = '';
        }
        if (editNote) {
          editNote.style.display = editingEnabled ? 'block' : 'none';
        }
        // Rebuild the tables to apply or remove editable fields
        buildTableView();
        buildProjectsTableView();
      });
    }

    // Filter select change handler: apply filter and search together
    const filterSelect = document.getElementById('tableFilterSelect');
    if (filterSelect) {
      filterSelect.addEventListener('change', () => {
        filterTable(tableSearchInput.value.trim().toLowerCase());
      });
    }

    // Update the map title when edited in the table overlay
    if (editTitleInput) {
      editTitleInput.addEventListener('input', () => {
        if (!aimData) return;
        aimData.title = editTitleInput.value.trim();
        // Update page title bar and document title
        const name = aimData.title || '';
        let pageTitle;
        if (name) {
          pageTitle = `AIM (Aspirational Identity Map): ${name}`;
        } else {
          const modeLabel = aimData.mode === 'personal' ? 'Personal' : 'Business';
          pageTitle = `AIM (Aspirational Identity Map): ${modeLabel}`;
        }
        document.title = pageTitle;
        // Update only the text content inside the dedicated title span so we don't remove the header buttons
        const titleSpan = document.getElementById('titleText');
        if (titleSpan) {
          titleSpan.textContent = pageTitle;
        } else {
          // Fallback: update the entire titleBar text if the span is missing
          titleBar.text(pageTitle);
        }
      });
    }

    // Download the current AIM data as a CSV file
    if (downloadCsvBtn) {
      downloadCsvBtn.addEventListener('click', () => {
        if (!aimData) return;
        const rows = [];
        // Meta rows (no confidence values)
        rows.push({ label: 'title', title: '', belief: aimData.title || '', confidence: '', pillars: '' });
        rows.push({ label: 'mode', title: '', belief: aimData.mode || '', confidence: '', pillars: '' });
        // Pillar names (no confidence values)
        for (let i = 1; i <= 3; i++) {
          rows.push({ label: `pillar_name:${i}`, title: '', belief: aimData.pillarNames[i] || '', confidence: '', pillars: '' });
        }
        // Lenses (if any).  Each lens is stored under lens:1, lens:2, etc.
        if (aimData.lenses && aimData.lenses.length > 0) {
          aimData.lenses.forEach((lensObj, idx) => {
            const title = typeof lensObj.title === 'string' ? lensObj.title : '';
            const belief = typeof lensObj.belief === 'string' ? lensObj.belief : '';
            const conf = (typeof lensObj.confidence === 'number') ? lensObj.confidence : '';
            // Join pillar attachments into a semicolon‑separated string for export
            let pillarsStr = '';
            if (Array.isArray(lensObj.pillars) && lensObj.pillars.length > 0) {
              pillarsStr = lensObj.pillars.join(';');
            }
            rows.push({ label: `lens:${idx + 1}`, title: title, belief: belief, confidence: conf, pillars: pillarsStr });
          });
        }
        // Core belief with confidence
        rows.push({ label: 'core', title: aimData.core.title || '', belief: aimData.core.belief || '', confidence: aimData.core.confidence || 50, pillars: '' });
        // Pillars with confidence
        for (let p = 1; p <= 3; p++) {
          rows.push({ label: `pillar:${p}`, title: aimData.pillars[p].title || '', belief: aimData.pillars[p].belief || '', confidence: aimData.pillars[p].confidence || 50, pillars: '' });
        }
        // Subs and micros with confidence
        for (let p = 1; p <= 3; p++) {
          for (let s = 1; s <= 3; s++) {
            rows.push({ label: `sub:${p}:${s}`, title: aimData.subs[p][s].title || '', belief: aimData.subs[p][s].belief || '', confidence: aimData.subs[p][s].confidence || 50, pillars: '' });
            for (let m = 1; m <= 3; m++) {
              rows.push({ label: `micro:${p}:${s}:${m}`, title: aimData.micros[p][s][m].title || '', belief: aimData.micros[p][s][m].belief || '', confidence: aimData.micros[p][s][m].confidence || 50, pillars: '' });
            }
          }
        }
        // Convert to CSV including the confidence column
        // Include the pillars column when exporting lenses.  The csvFormat
        // function will include empty values for non‑lens rows automatically.
        // When exporting, include the title column in addition to belief and confidence.
        const csvContent = d3.csvFormat(rows, ['label','title','belief','confidence','pillars']);
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = (aimData.title ? aimData.title.replace(/\s+/g, '_') : 'aim_data') + '.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

 // Save button handler: triggers the same download as the "Download CSV" button
 if (saveBtn) {
   saveBtn.addEventListener('click', () => {
     if (downloadCsvBtn) {
       downloadCsvBtn.click();
     }
   });
 }

    // Keyboard shortcuts
    document.addEventListener('keydown', event => {
      // If overlay is open, Esc closes overlay only
      if (tableOverlay.style.display === 'flex') {
        if (event.key === 'Escape') {
          tableOverlay.style.display = 'none';
          event.preventDefault();
        }
        return;
      }
      // Escape performs the same as clicking the reset button: reload the page
      if (event.key === 'Escape') {
        event.preventDefault();
        // Reload page to refresh dataset and state
        window.location.reload();
      }
      // 1,2,3 keys open pillar focus
      if (event.key === '1' || event.key === '2' || event.key === '3') {
        const index = parseInt(event.key);
        if (aimData && index >= 1 && index <= 3) {
          currentState = 'B';
          selectedPillar = index;
          selectedSub = null;
          preselectedSub = null;
          updateChart();
          updateLegend();
          // Flash the sub ring to indicate navigation
          setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
        }
      }
    });

    // Projects view action buttons: delegate to existing buttons
    if (resetBtnProjects) {
      resetBtnProjects.addEventListener('click', () => {
        // Trigger the same behaviour as the original reset button
        if (resetBtn) resetBtn.click();
      });
    }
    if (uploadBtnProjects) {
      uploadBtnProjects.addEventListener('click', () => {
        // Trigger the file input for CSV upload
        if (csvFileInput) csvFileInput.click();
      });
    }
    if (viewTableBtnProjects) {
      viewTableBtnProjects.addEventListener('click', () => {
        // Open data overlay and show projects tab by default
        tableOverlay.style.display = 'flex';
        showDataTab('projects');
        tableSearchInput.value = '';
        filterTable('');
        if (editTitleInput) {
          editTitleInput.value = aimData && aimData.title ? aimData.title : '';
        }
      });
    }

    // Object to store computed radii for the current state; used for flash effects
    let currentRingRadii = {
      A: { pillarStart: 0, pillarEnd: 0, subStart: 0, subEnd: 0, microStart: 0, microEnd: 0 },
      B: { center: 0, subStart: 0, subEnd: 0, microStart: 0, microEnd: 0 },
      C: { center: 0, microStart: 0, microEnd: 0 }
    };

// Parse the default CSV on load from the embedded string.  Avoids
    // reliance on file loading in the file:// scheme which may fail.  After
    // parsing, attempt to load a dataset specified via URL query parameters
    // (e.g. ?csv=custom.csv or ?data=BASE64ENCODEDCSV).  If a query
    // parameter is supplied and successfully parsed, it will replace the
    // default data.  Once data loading is complete, initialise the page.
    
// Friendly notice when no AIM CSV is loaded
function showNoAIMFileNotice() {
  try {
    const aimView = document.getElementById('aimView');
    if (!aimView) return;
    const container = aimView.querySelector('#container');
    if (container) container.style.display = 'none';
    if (!document.getElementById('noDataNotice')) {
      const box = document.createElement('div');
      box.id = 'noDataNotice';
      box.style.margin = '16px';
      box.style.padding = '12px 14px';
      box.style.border = '1px solid #e0e0e0';
      box.style.background = '#fffbe6';
      box.style.borderRadius = '6px';
      box.style.fontSize = '0.95rem';
      box.innerHTML = `<strong>No AIM file found.</strong>
        <div style="margin-top:6px;">
          This page isn’t pointed to an AIM CSV yet. Please upload an AIM file with the <em>Upload CSV</em> button above,
          or add <code>?csv=your-file.csv</code> to the URL.
        </div>`;
      aimView.prepend(box);
    }
  } catch (e) { console.warn('Unable to show missing file notice:', e); }
}

// Load only from query (no embedded demo data). If none found, show a friendly message.
(async function() {
  try {
    await loadFromQuery();
    if (!aimData) {
      showNoAIMFileNotice();
      return;
    }
    initialisePage();
  } catch (err) {
    console.error('App initialisation error:', err);
    showNoAIMFileNotice();
  }
})();


    /**
     * Parses CSV rows into a structured AIM object.
     * The input rows must have a `label` column (case-insensitive) and a
     * `belief` column.  The parser supports optional meta rows for title,
     * mode and pillar_name overrides.  Missing beliefs are left empty.
     */
    function parseCSV(rows) {
        const data = {
        title: '',
        mode: 'business',
        pillarNames: {},
        // core belief and its confidence
        core: { label: '', belief: '', confidence: 50 },
        // pillar, sub and micro structures each include belief and confidence
        pillars: {},
        subs: {},
        micros: {},
        // lenses array: arbitrary list of lens objects
        lenses: [],
        // projects array: holds any projects defined in the CSV
        projects: []
      };
      rows.forEach(row => {
        if (!row.label) return;
        const label = String(row.label).trim().toLowerCase();
        const title = row.title !== undefined ? String(row.title).trim() : '';
        // Optional last updated date/time field.  Store as raw string for later formatting.
        const updated = row.updated !== undefined ? String(row.updated).trim() : '';
        const belief = row.belief !== undefined ? String(row.belief).trim() : '';
        // Parse optional confidence column (0-100).  Default to 50 if missing or invalid
        let confidence = 50;
        if (row.confidence !== undefined && row.confidence !== '') {
          const num = parseFloat(row.confidence);
          if (!isNaN(num)) {
            confidence = Math.max(0, Math.min(100, num));
          }
        }
        // Parse segmentation pole values.  Poles can be specified either in a combined form (pole_ac, pole_ce, pole_cx)
        // or via separate score and label columns (ac_score/ac_label, cp_score/cp_label, ce_score/ce_label).  If both
        // forms are present, the split form takes precedence.
        function parsePole(str) {
          if (typeof str !== 'string' || str.trim() === '') return { value: null, letter: null };
          const s = str.trim();
          let match = s.match(/^(-?\d+)/);
          let val = null;
          if (match) {
            val = parseInt(match[1]);
          }
          let letter = null;
          const last = s[s.length - 1];
          if (/[A-Za-z]/.test(last)) {
            letter = last.toUpperCase();
          }
          return { value: isNaN(val) ? null : val, letter: letter };
        }
        // Helper to parse separate score/label columns
        function parseSplitPole(scoreStr, labelStr) {
          // Parse separate segmentation pole score and label fields.  The score
          // should be an integer; the label column is treated purely as a
          // descriptive phrase and should not be used to derive the
          // orientation letter unless it is a single character (A, C, D, G, P, S).
          let value = null;
          if (scoreStr !== undefined && scoreStr !== null && scoreStr !== '') {
            const num = parseInt(scoreStr);
            if (!isNaN(num)) value = num;
          }
          let letter = null;
          if (labelStr !== undefined && labelStr !== null) {
            const trimmed = String(labelStr).trim();
            // Only treat the label as an orientation letter if it is a single character.
            if (trimmed.length === 1) {
              letter = trimmed.toUpperCase();
            }
          }
          return { value: value, letter: letter };
        }
        // Start with combined pole columns
        let poleAc = parsePole(row.pole_ac);
        let poleCe = parsePole(row.pole_ce);
        let poleCx = parsePole(row.pole_cx);
        // Override with split pole columns if provided
        const splitAc = parseSplitPole(row.ac_score, row.ac_label);
        if (splitAc.value !== null || splitAc.letter !== null) {
          poleAc = {
            value: splitAc.value !== null ? splitAc.value : poleAc.value,
            letter: splitAc.letter !== null ? splitAc.letter : poleAc.letter
          };
        }
        // Celebration and Collective experience may be stored in either cp_* or ce_* columns.
        // According to the latest schema, cp_score/cp_label correspond to the Celebration pole
        // (Destination ↔ Practice) and ce_score/ce_label correspond to the Collective experience pole
        // (Asynchronous ↔ Synchronized).  Override poleCe and poleCx with these values if present.
        const splitCelebration = parseSplitPole(row.cp_score, row.cp_label);
        if (splitCelebration.value !== null || splitCelebration.letter !== null) {
          poleCe = {
            value: splitCelebration.value !== null ? splitCelebration.value : poleCe.value,
            letter: splitCelebration.letter !== null ? splitCelebration.letter : poleCe.letter
          };
        }
        const splitCollective = parseSplitPole(row.ce_score, row.ce_label);
        if (splitCollective.value !== null || splitCollective.letter !== null) {
          poleCx = {
            value: splitCollective.value !== null ? splitCollective.value : poleCx.value,
            letter: splitCollective.letter !== null ? splitCollective.letter : poleCx.letter
          };
        }
        // Persist pole labels for use in tooltips and table.  We store the raw label strings if provided.
        const poleAcLabel = row.ac_label !== undefined ? String(row.ac_label).trim() : '';
        const poleCeLabel = row.cp_label !== undefined ? String(row.cp_label).trim() : '';
        const poleCxLabel = row.ce_label !== undefined ? String(row.ce_label).trim() : '';
        // Capture optional state, details, priority and new project fields
        const todayState = row.today_state !== undefined ? String(row.today_state).trim() : '';
        const detailsVal = row.details !== undefined ? String(row.details).trim() : '';
        const priorityUser = row.priority_human !== undefined ? String(row.priority_human).trim() : '';
        const priorityAi = row.priority_ai !== undefined ? String(row.priority_ai).trim() : '';
        const projectOutcome = row.project_outcome !== undefined ? String(row.project_outcome).trim() : '';
        const projectAcceptance = row.project_acceptance !== undefined ? String(row.project_acceptance).trim() : '';
        const projectRef = row.project_ref !== undefined ? String(row.project_ref).trim() : '';
        // New schema: project type and duration (for sprint projects).  project_type
        // defines whether a row represents a practice or sprint project.  Duration
        // applies only to sprint projects.  Types are lowercased for consistency.
        const projectType = row.project_type !== undefined ? String(row.project_type).trim().toLowerCase() : '';
        const durationVal = row.duration !== undefined ? String(row.duration).trim() : '';
        // Capture legacy project fields (AIM‑1) for backward compatibility
        const projectAction = row.project_action !== undefined ? String(row.project_action).trim() : '';
        const projectMeasure = row.project_measure !== undefined ? String(row.project_measure).trim() : '';
        const projectStart = row.project_start !== undefined && row.project_start !== '' ? parseFloat(row.project_start) : null;
        const projectTarget = row.project_target !== undefined && row.project_target !== '' ? parseFloat(row.project_target) : null;
        const projectDays = row.project_days_per_week !== undefined && row.project_days_per_week !== '' ? parseInt(row.project_days_per_week) : null;
        const projectBenefit = row.project_benefit !== undefined ? String(row.project_benefit).trim() : '';
        if (label === 'title') {
          data.title = belief;
          return;
        }
        if (label === 'mode') {
  const modeStr = (belief && belief.trim()) ? belief.trim() : ((title && title.trim()) ? title.trim() : '');
  data.mode = modeStr.toLowerCase() === 'personal' ? 'personal' : 'business';
  return;
}
        if (label.startsWith('pillar_name:')) {
          const idx = parseInt(label.split(':')[1]);
          if (idx >= 1 && idx <= 3) {
            data.pillarNames[idx] = belief;
          }
          return;
        }
        if (label === 'core') {
          // Store core belief and associated metadata
          data.core = {
            label: 'Core',
            title: title || '',
            belief: belief,
            confidence: confidence,
            updated: updated,
            pole_ac_value: poleAc.value,
            pole_ac_letter: poleAc.letter,
            pole_ce_value: poleCe.value,
            pole_ce_letter: poleCe.letter,
            pole_cx_value: poleCx.value,
            pole_cx_letter: poleCx.letter,
            today_state: todayState,
            details: detailsVal,
            priority_human: priorityUser,
            priority_ai: priorityAi
            ,
            pole_ac_label: poleAcLabel,
            pole_ce_label: poleCeLabel,
            pole_cx_label: poleCxLabel
          };
          // If project fields present, record project associated with this core (pillar null)
          const hasLegacyProj = projectAction || projectMeasure || projectStart !== null || projectTarget !== null || projectDays !== null || projectBenefit;
          const hasNewProj = projectOutcome || projectAcceptance || projectRef;
          if (hasLegacyProj || hasNewProj) {
            if (!data.projects) data.projects = [];
            data.projects.push({
              action: projectAction || (title || belief),
              measure: projectMeasure,
              start: projectStart,
              target: projectTarget,
              days: projectDays,
              benefit: projectBenefit,
              priority_user: priorityUser,
              priority_ai: priorityAi,
              outcome: projectOutcome,
              acceptance: projectAcceptance,
              ref: projectRef,
              today_state: todayState,
              details: detailsVal,
              pillar: null,
              // Record project type and duration for new schema.  Default type to
              // 'practice' if not provided but legacy fields exist.
              type: projectType || (hasLegacyProj ? 'practice' : ''),
              duration: durationVal
            });
          }
          return;
        }
        if (label.startsWith('pillar:')) {
          const idx = parseInt(label.split(':')[1]);
          if (!data.pillars[idx]) data.pillars[idx] = { title: '', belief: '', confidence: 50 };
          data.pillars[idx].title = title || '';
          data.pillars[idx].belief = belief;
          data.pillars[idx].confidence = confidence;
          data.pillars[idx].updated = updated;
          data.pillars[idx].pole_ac_value = poleAc.value;
          data.pillars[idx].pole_ac_letter = poleAc.letter;
          data.pillars[idx].pole_ce_value = poleCe.value;
          data.pillars[idx].pole_ce_letter = poleCe.letter;
          data.pillars[idx].pole_cx_value = poleCx.value;
          data.pillars[idx].pole_cx_letter = poleCx.letter;
          // Store the raw label strings if provided for tooltips and table display
          data.pillars[idx].pole_ac_label = poleAcLabel;
          data.pillars[idx].pole_ce_label = poleCeLabel;
          data.pillars[idx].pole_cx_label = poleCxLabel;
          data.pillars[idx].today_state = todayState;
          data.pillars[idx].details = detailsVal;
          data.pillars[idx].priority_human = priorityUser;
          data.pillars[idx].priority_ai = priorityAi;
          // Capture any project fields on pillar rows
          const hasLegacyProjP = projectAction || projectMeasure || projectStart !== null || projectTarget !== null || projectDays !== null || projectBenefit;
          const hasNewProjP = projectOutcome || projectAcceptance || projectRef;
          if (hasLegacyProjP || hasNewProjP) {
            if (!data.projects) data.projects = [];
            data.projects.push({
              action: projectAction || (title || belief),
              measure: projectMeasure,
              start: projectStart,
              target: projectTarget,
              days: projectDays,
              benefit: projectBenefit,
              priority_user: priorityUser,
              priority_ai: priorityAi,
              outcome: projectOutcome,
              acceptance: projectAcceptance,
              ref: projectRef,
              today_state: todayState,
              details: detailsVal,
              pillar: idx,
              type: projectType || (hasLegacyProjP ? 'practice' : ''),
              duration: durationVal
            });
          }
          return;
        }
        if (label.startsWith('sub:')) {
          const parts = label.split(':');
          const p = parseInt(parts[1]);
          const s = parseInt(parts[2]);
          if (!data.subs[p]) data.subs[p] = {};
          if (!data.subs[p][s]) data.subs[p][s] = { title: '', belief: '', confidence: 50 };
          data.subs[p][s].title = title || '';
          data.subs[p][s].belief = belief;
          data.subs[p][s].confidence = confidence;
          data.subs[p][s].updated = updated;
          data.subs[p][s].pole_ac_value = poleAc.value;
          data.subs[p][s].pole_ac_letter = poleAc.letter;
          data.subs[p][s].pole_ce_value = poleCe.value;
          data.subs[p][s].pole_ce_letter = poleCe.letter;
          data.subs[p][s].pole_cx_value = poleCx.value;
          data.subs[p][s].pole_cx_letter = poleCx.letter;
          data.subs[p][s].pole_ac_label = poleAcLabel;
          data.subs[p][s].pole_ce_label = poleCeLabel;
          data.subs[p][s].pole_cx_label = poleCxLabel;
          data.subs[p][s].today_state = todayState;
          data.subs[p][s].details = detailsVal;
          data.subs[p][s].priority_human = priorityUser;
          data.subs[p][s].priority_ai = priorityAi;
          // Project fields on sub rows attach to this pillar
          const hasLegacyProjS = projectAction || projectMeasure || projectStart !== null || projectTarget !== null || projectDays !== null || projectBenefit;
          const hasNewProjS = projectOutcome || projectAcceptance || projectRef;
          if (hasLegacyProjS || hasNewProjS) {
            if (!data.projects) data.projects = [];
            data.projects.push({
              action: projectAction || (title || belief),
              measure: projectMeasure,
              start: projectStart,
              target: projectTarget,
              days: projectDays,
              benefit: projectBenefit,
              priority_user: priorityUser,
              priority_ai: priorityAi,
              outcome: projectOutcome,
              acceptance: projectAcceptance,
              ref: projectRef,
              today_state: todayState,
              details: detailsVal,
              pillar: p,
              type: projectType || (hasLegacyProjS ? 'practice' : ''),
              duration: durationVal
            });
          }
          return;
        }
        if (label.startsWith('micro:')) {
          const parts = label.split(':');
          const p = parseInt(parts[1]);
          const s = parseInt(parts[2]);
          const m = parseInt(parts[3]);
          if (!data.micros[p]) data.micros[p] = {};
          if (!data.micros[p][s]) data.micros[p][s] = {};
          data.micros[p][s][m] = {
            title: title || '',
            belief: belief,
            confidence: confidence,
            updated: updated,
            pole_ac_value: poleAc.value,
            pole_ac_letter: poleAc.letter,
            pole_ce_value: poleCe.value,
            pole_ce_letter: poleCe.letter,
            pole_cx_value: poleCx.value,
            pole_cx_letter: poleCx.letter,
            pole_ac_label: poleAcLabel,
            pole_ce_label: poleCeLabel,
            pole_cx_label: poleCxLabel,
            today_state: todayState,
            details: detailsVal,
            priority_human: priorityUser,
            priority_ai: priorityAi
          };
          // Project fields on micro rows attach to this pillar
          const hasLegacyProjM = projectAction || projectMeasure || projectStart !== null || projectTarget !== null || projectDays !== null || projectBenefit;
          const hasNewProjM = projectOutcome || projectAcceptance || projectRef;
          if (hasLegacyProjM || hasNewProjM) {
            if (!data.projects) data.projects = [];
            data.projects.push({
              action: projectAction || (title || belief),
              measure: projectMeasure,
              start: projectStart,
              target: projectTarget,
              days: projectDays,
              benefit: projectBenefit,
              priority_user: priorityUser,
              priority_ai: priorityAi,
              outcome: projectOutcome,
              acceptance: projectAcceptance,
              ref: projectRef,
              today_state: todayState,
              details: detailsVal,
              pillar: p,
              type: projectType || (hasLegacyProjM ? 'practice' : ''),
              duration: durationVal
            });
          }
          return;
        }
        // Lenses: any label starting with 'lens' will be treated as a lens entry.
        // Lenses accept optional confidence values and pillar attachments.  If the
        // CSV includes a 'pillars' column, parse it as a comma/semicolon‑separated
        // list of pillar indices (1–3).  Each lens is stored as an object
        // containing the belief text, confidence and a list of associated
        // pillars.  Missing confidence defaults to 50 and missing pillars
        // default to an empty array.  Labels may be like 'lens', 'lens:1', etc.
        
        // Standalone project rows (AIM-1.6). Accept alias columns.
        if (label === 'project') {
          if (!data.projects) data.projects = [];
          const pType = (projectType && projectType.toLowerCase() === 'sprint') ? 'sprint' : 'practice';
          // Accept alias columns used in S2.1
          const measureVal = (row.project_measure !== undefined && String(row.project_measure).trim() !== '')
            ? String(row.project_measure).trim()
            : (row.how_we_count !== undefined ? String(row.how_we_count).trim() : '');
          const startVal = (row.project_start !== undefined && row.project_start !== '')
            ? String(row.project_start).trim()
            : (row.start_amount !== undefined ? String(row.start_amount).trim() : '');
          const targetVal = (row.project_target !== undefined && row.project_target !== '')
            ? String(row.project_target).trim()
            : (row.target_amount !== undefined ? String(row.target_amount).trim() : '');
          const daysVal = (row.project_days_per_week !== undefined && row.project_days_per_week !== '')
            ? String(row.project_days_per_week).trim()
            : (row.days_per_week !== undefined ? String(row.days_per_week).trim() : '');
          const proj = {
            action: (row.project_action && String(row.project_action).trim() !== '') ? String(row.project_action).trim() : (title || belief || ''),
            benefit: (row.project_benefit !== undefined ? String(row.project_benefit).trim() : ''),
            type: pType,
            duration: (pType === 'sprint') ? (durationVal || '') : '',
            measure: (pType === 'sprint') ? '' : measureVal,
            start: (pType === 'sprint') ? '' : startVal,
            target: (pType === 'sprint') ? '' : targetVal,
            days: (pType === 'sprint') ? '' : daysVal,
            priority_user: (row.priority_user !== undefined ? String(row.priority_user).trim() : (row.user_priority !== undefined ? String(row.user_priority).trim() : (row.priority_human !== undefined ? String(row.priority_human).trim() : ''))),
            priority_ai: (row.priority_ai !== undefined ? String(row.priority_ai).trim() : (row.ai_priority !== undefined ? String(row.ai_priority).trim() : '')),
            today_state: (row.today_state !== undefined ? String(row.today_state).trim() : ''),
            details: (row.details !== undefined ? String(row.details).trim() : ''),
            outcome: (row.project_outcome !== undefined ? String(row.project_outcome).trim() : ''),
            acceptance: (row.project_acceptance !== undefined ? String(row.project_acceptance).trim() : ''),
            ref: (row.project_ref !== undefined ? String(row.project_ref).trim() : ''),
            pillar: null
          };
          data.projects.push(proj);
          return;
        }
if (label.startsWith('lens')) {
          if (belief) {
            let pillarsList = [];
            // Attempt to parse pillars from row.pillars if present
            if (row.pillars !== undefined && row.pillars !== '') {
              const raw = String(row.pillars).trim();
              raw.split(/[;,]/).forEach(part => {
                const val = parseInt(part.trim());
                if (!isNaN(val) && val >= 1 && val <= 3) {
                  pillarsList.push(val);
                }
              });
            }
            if (!data.lenses) data.lenses = [];
            // Assign lens index based on current count before push
            const lensObj = {
              title: title || '',
              belief: belief,
              confidence: confidence,
              pillars: pillarsList,
              updated: updated,
              pole_ac_value: poleAc.value,
              pole_ac_letter: poleAc.letter,
              pole_ce_value: poleCe.value,
              pole_ce_letter: poleCe.letter,
              pole_cx_value: poleCx.value,
              pole_cx_letter: poleCx.letter,
              pole_ac_label: poleAcLabel,
              pole_ce_label: poleCeLabel,
              pole_cx_label: poleCxLabel,
              today_state: todayState,
              details: detailsVal,
              priority_human: priorityUser,
              priority_ai: priorityAi
            };
            lensObj.lensIndex = data.lenses.length;
            data.lenses.push(lensObj);
          }
          return;
        }
      });
      
      // Prefer pillar row titles as pillar names everywhere (legend, lenses, center).
      for (let i = 1; i <= 3; i++) {
        if (data.pillars[i] && data.pillars[i].title && data.pillars[i].title.trim() !== '') {
          data.pillarNames[i] = data.pillars[i].title.trim();
        }
      }
// Set default pillar names based on mode if missing
      const defaultNames = data.mode === 'personal'
        ? ['Outer Self','Inner Self','Relationships']
        : ['Team','Revenue','Customer'];
      for (let i = 1; i <= 3; i++) {
        if (!data.pillars[i]) data.pillars[i] = { title:'', belief: '', confidence: 50, updated:'', pole_ac_value:null, pole_ac_letter:null, pole_ce_value:null, pole_ce_letter:null, pole_cx_value:null, pole_cx_letter:null, pole_ac_label:'', pole_ce_label:'', pole_cx_label:'', today_state:'', details:'', priority_human:'', priority_ai:'' };
        if (!data.pillarNames[i]) data.pillarNames[i] = defaultNames[i - 1];
        if (!data.subs[i]) data.subs[i] = {};
        if (!data.micros[i]) data.micros[i] = {};
        for (let j = 1; j <= 3; j++) {
          if (!data.subs[i][j]) data.subs[i][j] = { title:'', belief: '', confidence: 50, updated:'', pole_ac_value:null, pole_ac_letter:null, pole_ce_value:null, pole_ce_letter:null, pole_cx_value:null, pole_cx_letter:null, pole_ac_label:'', pole_ce_label:'', pole_cx_label:'', today_state:'', details:'', priority_human:'', priority_ai:'' };
          if (!data.micros[i][j]) data.micros[i][j] = {};
          for (let k = 1; k <= 3; k++) {
            if (!data.micros[i][j][k]) data.micros[i][j][k] = { title:'', belief: '', confidence: 50, updated:'', pole_ac_value:null, pole_ac_letter:null, pole_ce_value:null, pole_ce_letter:null, pole_cx_value:null, pole_cx_letter:null, pole_ac_label:'', pole_ce_label:'', pole_cx_label:'', today_state:'', details:'', priority_human:'', priority_ai:'' };
          }
        }
      }
      return data;
    }

    /**
     * Attempts to load a CSV dataset from the URL query parameters.  If
     * ?csv=filename is present, a fetch is issued to retrieve the file
     * relative to the page.  If ?data=base64 is present, the parameter
     * value is Base64‑decoded and parsed as CSV text.  If no query
     * parameters are provided or loading fails, the existing aimData
     * remains unchanged.  This function returns a promise so that the
     * caller can await its completion before rendering.
     */
    async function loadFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search);
        // Load from ?csv=filename.csv
        if (params.has('csv')) {
          const fileName = params.get('csv');
          if (fileName) {
            // Try to retrieve from localStorage first (works for file:// origin)
            try {
              const stored = localStorage.getItem('aim_csv_' + fileName);
              if (stored) {
                const rows = d3.csvParse(stored);
                aimData = parseCSV(rows);
                
      // SK: After successful parse, hide missing-file notice and render
      (function SK_onUploadSuccess(){
        try {
          const notice = document.getElementById('noDataNotice');
          if (notice) notice.remove();
          const container = document.querySelector('#aimView #container');
          if (container) container.style.display = '';
        } catch(_) {}
        if (typeof initialisePage === 'function') {
          initialisePage();
        } else {
          // Fallback: update key UI pieces
          if (typeof updateLegend === 'function') updateLegend();
          if (typeof updateLenses === 'function') updateLenses();
          if (typeof updateChart === 'function') updateChart();
          if (typeof updateProjectsView === 'function') updateProjectsView();
        }
      })();
    return;
              }
            } catch (err) {
              console.warn('Error reading CSV from localStorage:', err);
            }
            // Fall back to network fetch (works on hosted environments)
            try {
              const response = await fetch(fileName);
              if (!response.ok) {
                console.warn('Could not load CSV from', fileName, response.status);
              } else {
                const text = await response.text();
                const rows = d3.csvParse(text);
                aimData = parseCSV(rows);
                
      // SK: After successful parse, hide missing-file notice and render
      (function SK_onUploadSuccess(){
        try {
          const notice = document.getElementById('noDataNotice');
          if (notice) notice.remove();
          const container = document.querySelector('#aimView #container');
          if (container) container.style.display = '';
        } catch(_) {}
        if (typeof initialisePage === 'function') {
          initialisePage();
        } else {
          // Fallback: update key UI pieces
          if (typeof updateLegend === 'function') updateLegend();
          if (typeof updateLenses === 'function') updateLenses();
          if (typeof updateChart === 'function') updateChart();
          if (typeof updateProjectsView === 'function') updateProjectsView();
        }
      })();
    return;
              }
            } catch (err) {
              console.error('Error fetching CSV from query parameter:', err);
            }
          }
        }
        // Load from ?data=BASE64ENCODEDCSV
        if (params.has('data')) {
          const encoded = params.get('data');
          if (encoded) {
            try {
              // Decode from base64 (URL‑safe) and URI component decoding
              const decoded = atob(decodeURIComponent(encoded));
              const rows = d3.csvParse(decoded);
              aimData = parseCSV(rows);
              
      // SK: After successful parse, hide missing-file notice and render
      (function SK_onUploadSuccess(){
        try {
          const notice = document.getElementById('noDataNotice');
          if (notice) notice.remove();
          const container = document.querySelector('#aimView #container');
          if (container) container.style.display = '';
        } catch(_) {}
        if (typeof initialisePage === 'function') {
          initialisePage();
        } else {
          // Fallback: update key UI pieces
          if (typeof updateLegend === 'function') updateLegend();
          if (typeof updateLenses === 'function') updateLenses();
          if (typeof updateChart === 'function') updateChart();
          if (typeof updateProjectsView === 'function') updateProjectsView();
        }
      })();
    return;
            } catch (err) {
              console.error('Error decoding CSV data from query parameter:', err);
            }
          }
        }
      } catch (err) {
        console.error('Error processing query parameters:', err);
      }
    }

    /**
     * Handles file uploads from the file input.  The uploaded CSV is parsed
     * and replaces the current AIM dataset.  Errors are logged to the console.
     */
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const text = e.target.result;
          const rows = d3.csvParse(text);
          aimData = parseCSV(rows);
          
      // SK: After successful parse, hide missing-file notice and render
      (function SK_onUploadSuccess(){
        try {
          const notice = document.getElementById('noDataNotice');
          if (notice) notice.remove();
          const container = document.querySelector('#aimView #container');
          if (container) container.style.display = '';
        } catch(_) {}
        if (typeof initialisePage === 'function') {
          initialisePage();
        } else {
          // Fallback: update key UI pieces
          if (typeof updateLegend === 'function') updateLegend();
          if (typeof updateLenses === 'function') updateLenses();
          if (typeof updateChart === 'function') updateChart();
          if (typeof updateProjectsView === 'function') updateProjectsView();
        }
      })();
    // Reset view state
          currentState = 'A';
          selectedPillar = null;
          selectedSub = null;
          preselectedSub = null;
          // Persist the uploaded CSV content in localStorage keyed by file name
          try {
            const fileName = file.name;
            if (fileName) {
              localStorage.setItem('aim_csv_' + fileName, text);
              // Update the URL query to reference the uploaded file
              const basePath = window.location.pathname;
              const newUrl = basePath + '?csv=' + encodeURIComponent(fileName);
              window.history.replaceState(null, '', newUrl);
            }
          } catch (errStorage) {
            console.warn('Could not store uploaded CSV in localStorage:', errStorage);
          }
          initialisePage();
          // Reset the file input value so that selecting the same file again
          // triggers a change event.  Without this reset, re‑uploading the
          // same file may not fire the change event due to the input
          // retaining its previous value.
          event.target.value = '';
        } catch (err) {
          console.error('Error parsing uploaded CSV:', err);
        }
      };
      reader.readAsText(file);
    }

    /**
     * Initialise the page once the AIM data is loaded or replaced.  This
     * function populates the legend and renders the chart for the first time.
     */
    function initialisePage() {
      // Update page title
      // Build title: AIM (Aspirational Identity Map): <Name>.  If no name provided,
      // fall back to mode (Business/Personal) description.
      const name = aimData.title || '';
      let pageTitle;
      if (name) {
        pageTitle = `AIM (Aspirational Identity Map): ${name}`;
      } else {
        const modeLabel = aimData.mode === 'personal' ? 'Personal' : 'Business';
        pageTitle = `AIM (Aspirational Identity Map): ${modeLabel}`;
      }
      document.title = pageTitle;
      // Update only the title text inside the span so we preserve header actions
      const titleSpan = document.getElementById('titleText');
      if (titleSpan) {
        titleSpan.textContent = pageTitle;
      } else {
        titleBar.text(pageTitle);
      }
      // Render legend
      updateLegend();
      // Update the lenses block in the sidebar
      updateLenses();
      // Draw the chart
      updateChart();
      // Update the projects view if visible or precompute for later
      if (typeof updateProjectsView === 'function') {
        updateProjectsView();
      }
    }

    /**
     * Populates the lenses section of the sidebar.  Displays a list of
     * lenses or a default message if no lenses are present.  A bullet
     * character precedes each lens for visual separation.
     */
    function updateLenses() {
      const listEl = document.getElementById('lensesList');
      const titleEl = document.getElementById('lensesTitle');
      if (!listEl || !titleEl) return;
      // Determine if we should filter lenses by the selected pillar.  In global state (A),
      // we show all lenses.  In pillar (B) or sub focus (C) we show only
      // lenses whose pillars list includes the current selectedPillar.
      let lensesToShow = [];
      let heading = 'Lenses';
      if (aimData && Array.isArray(aimData.lenses) && aimData.lenses.length > 0) {
        if (currentState !== 'A' && selectedPillar) {
          // Filter lenses that apply to the selected pillar
          lensesToShow = aimData.lenses.filter(l => Array.isArray(l.pillars) && l.pillars.includes(selectedPillar));
          heading = (aimData.pillarNames[selectedPillar] || '') + ' lenses';
        } else {
          // Show all lenses
          lensesToShow = aimData.lenses.slice();
        }
      }
      // Update the lenses heading
      titleEl.textContent = heading;
      // If no lenses to show
      if (!lensesToShow || lensesToShow.length === 0) {
        listEl.textContent = 'No lenses';
        return;
      }
      // Clear existing list
      listEl.innerHTML = '';
      // Sort by confidence descending and limit to top 5
      const sorted = lensesToShow.slice().sort((a, b) => {
        const ca = (typeof a.confidence === 'number') ? a.confidence : 50;
        const cb = (typeof b.confidence === 'number') ? b.confidence : 50;
        return cb - ca;
      });
      const topLenses = sorted.slice(0, 5);
      topLenses.forEach(lens => {
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '6px';
        container.style.cursor = 'default';
        // Dot colour: depends on heatmap selection
        const dot = document.createElement('span');
        dot.style.display = 'inline-block';
        dot.style.width = '10px';
        dot.style.height = '10px';
        dot.style.borderRadius = '50%';
        let color;
        // Determine colour based on current heatmapType
        if (heatmapType === 'confidence') {
          const val = (typeof lens.confidence === 'number') ? lens.confidence : 50;
          const heat = computeHeatColor(Math.max(0, Math.min(100, val)));
          color = `rgb(${heat[0]},${heat[1]},${heat[2]})`;
        } else if (heatmapType === 'ac') {
          const v = (lens.pole_ac_value !== null && lens.pole_ac_value !== undefined) ? lens.pole_ac_value : 0;
          const mapped = ((v + 3) / 6) * 100;
          const heat = computeHeatColor(mapped);
          color = `rgb(${heat[0]},${heat[1]},${heat[2]})`;
        } else if (heatmapType === 'ce') {
          const v = (lens.pole_ce_value !== null && lens.pole_ce_value !== undefined) ? lens.pole_ce_value : 0;
          const mapped = ((v + 3) / 6) * 100;
          const heat = computeHeatColor(mapped);
          color = `rgb(${heat[0]},${heat[1]},${heat[2]})`;
        } else if (heatmapType === 'cx') {
          const v = (lens.pole_cx_value !== null && lens.pole_cx_value !== undefined) ? lens.pole_cx_value : 0;
          const mapped = ((v + 3) / 6) * 100;
          const heat = computeHeatColor(mapped);
          color = `rgb(${heat[0]},${heat[1]},${heat[2]})`;
        } else {
          // Off: neutral grey dot
          color = '#888888';
        }
        dot.style.backgroundColor = color;
        container.appendChild(dot);
        // Lens text (truncate long titles/beliefs for display).  Use lens.title if provided; fall back to belief text.
        const textSpan = document.createElement('span');
        const baseText = (lens.title && lens.title.length > 0) ? lens.title.trim() : (typeof lens.belief === 'string' ? lens.belief.trim() : '');
        const displayText = baseText.length > 50 ? baseText.slice(0, 47).trim() + '…' : baseText;
        textSpan.textContent = displayText;
        textSpan.style.flex = '1';
        textSpan.style.fontSize = '0.85rem';
        textSpan.style.color = '#333';
        // Use title attribute to show full lens belief on hover
        const fullLensText = (typeof lens.belief === 'string') ? lens.belief.trim() : '';
        textSpan.setAttribute('title', fullLensText);
        container.appendChild(textSpan);
        // Append small coloured squares for pillar attachments
        if (Array.isArray(lens.pillars) && lens.pillars.length > 0) {
          const attachContainer = document.createElement('span');
          attachContainer.style.display = 'flex';
          attachContainer.style.gap = '3px';
          lens.pillars.forEach(pillarIdx => {
            const sq = document.createElement('span');
            sq.style.display = 'inline-block';
            sq.style.width = '8px';
            sq.style.height = '8px';
            sq.style.borderRadius = '2px';
            const rgb = pillarBases[pillarIdx - 1] || [136,136,136];
            const attachColor = `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${depthAlpha[1]})`;
            sq.style.backgroundColor = attachColor;
            attachContainer.appendChild(sq);
          });
          container.appendChild(attachContainer);
        }
        // Attach tooltip events for lens: show full lens details
        container.addEventListener('mouseenter', (e) => {
          showTooltip(e, lens);
        });
        container.addEventListener('mousemove', (e) => {
          moveTooltip(e);
        });
        container.addEventListener('mouseleave', (e) => {
          hideTooltip();
        });
        listEl.appendChild(container);
      });
    }

    /**
     * Updates the legend chips based on the current AIM data and state.  The
     * legend indicates which pillar is active and supports hover and click
     * interactions to navigate to pillar focus.
     */
    function updateLegend() {
      if (!aimData) return;
      const data = [1,2,3];
      const chips = legendContainer.selectAll('.legend-chip').data(data);
      // Enter
      const chipsEnter = chips.enter().append('div')
        .attr('class','legend-chip')
        .attr('role','button')
        .attr('tabindex','0')
        .attr('aria-pressed','false')
        .on('click', (event, d) => {
          event.preventDefault();
          handleLegendClick(d);
        });
      chipsEnter.append('div').attr('class','dot');
      chipsEnter.append('div').attr('class','label');
      // Update
      const allChips = chipsEnter.merge(chips);
      allChips
        .classed('selected', d => d === selectedPillar)
        .each(function(d) {
          const chip = d3.select(this);
          chip.select('.dot').style('background-color', () => {
            const rgb = pillarBases[d-1];
            return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${depthAlpha[1]})`;
          });
          chip.select('.label').text(aimData.pillarNames[d] || '');
          chip.attr('aria-pressed', (d === selectedPillar).toString());
        });
    }

    /**
     * Handles clicks on legend chips.  Clicking a chip always brings the
     * corresponding pillar into focus (State B).  If already focused on that
     * pillar, no change occurs.  When in State C, clicking a legend chip
     * switches to pillar focus without going to State A first.
     */
    function handleLegendClick(pillarIdx) {
      if (!aimData) return;
      if (selectedPillar === pillarIdx && currentState === 'B') return;
      selectedPillar = pillarIdx;
      selectedSub = null;
      preselectedSub = null;
      currentState = 'B';
      updateChart();
      updateLegend();
      // Flash the sub ring to indicate navigation
      setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
    }

    /**
     * Computes the colour for a wedge based on its pillar index and depth.  The
     * colour parity rule is implemented here: each pillar’s base RGB is used
     * with a depth‑specific alpha value.  See the spec for exact values.
     */
    function computeFill(pillarIdx, depth) {
      const base = pillarBases[pillarIdx - 1];
      const alpha = depthAlpha[depth];
      return `rgba(${base[0]},${base[1]},${base[2]},${alpha})`;
    }

    /**
     * Compute radii for the current view based on the SVG size.  This helper
     * returns an object containing inner and outer radii for each ring in each
     * state.  Radii are computed as fractions of the available radius so the
     * chart scales with its container.  Small gaps are inserted between rings
     * to visually separate layers.
     */
    function computeRadii() {
      // The chart should remain square.  Compute the available size from the
      // parent container rather than the SVG itself (which may have zero
      // height if not explicitly sized).  Then set the SVG’s width and
      // height to enforce a square aspect ratio.
      /*
       * The chart must remain square and always fully visible on first load.  When
       * computing available space, the parent wrapper’s width can be zero if the
       * DOM has not finished layout (e.g. on first paint).  To avoid
       * collapsing to an infinitesimal size we estimate the width from the
       * container minus the sidebar.  The height is derived from the
       * viewport minus the header.  We then clamp the square size to the
       * lesser of these two values.  This approach ensures the graphic
       * appears at a consistent size at the top of the page and never
       * overflows the viewport.
       */
      const chartWrapper = svg.node().parentNode;
      const containerEl = document.getElementById('container');
      const sidebarEl = document.getElementById('sidebar');
      const titleBarEl = document.getElementById('titleBar');
      // Use the actual wrapper width if available; otherwise approximate from container
      const parentRect = chartWrapper.getBoundingClientRect();
      let containerWidth = containerEl ? containerEl.getBoundingClientRect().width : 0;
      let sidebarWidth = sidebarEl ? sidebarEl.getBoundingClientRect().width : 0;
      // If parentRect.width is 0 (layout not ready), fall back to container width minus sidebar
      let availableWidth = parentRect.width > 0 ? parentRect.width : Math.max(containerWidth - sidebarWidth - 32, 300);
      // Compute available height: viewport minus header and some padding
      const headerHeight = titleBarEl ? titleBarEl.getBoundingClientRect().height : 0;
      // 40px padding for margins
      let availableHeight = Math.max(window.innerHeight - headerHeight - 40, 300);
      const size = Math.min(availableWidth, availableHeight);
      // Apply the computed size to the SVG so subsequent calculations use
      // consistent dimensions.  Also set the wrapper height to maintain the
      // square area.
      svg.attr('width', size).attr('height', size);
      chartWrapper.style.height = size + 'px';
      const margin = 4; // small margin to avoid clipping
      const radius = (size / 2) - margin;
      // Define ring proportion constants for each state.  We allocate
      // significantly more space to the central disc and the ring of three
      // beliefs, while shrinking the sub and micro rings.  Ratios must
      // sum to 1.0.  Feel free to tweak these values to adjust legibility.
      // Global state (A): [core, pillar (3), sub (9), micro (27)]
      // Increase space for the core and pillar rings while shrinking the
      // outer rings.  These ratios sum to 1.0 and provide 45% of the
      // radius to the core, 35% to the ring of three, 15% to the sub
      // ring and 5% to the micro ring in the global view.  In pillar
      // focus, the centre receives 50%, subs 35% and micros 15%.  In
      // sub focus the centre uses 70% and the micro ring 30%.
    // Allocate more space to the core and the ring of three in the global view.  The
    // ratios represent [core, pillar (3), sub (9), micro (27)] and must sum to 1.0.
    // We dedicate 50% of the radius to the core disc, 35% to the ring of three,
    // leaving just 10% for the sub ring and 5% for the micro ring.  This
    // reduces clutter in the outer rings while giving text in the centre more
    // breathing room.
    const globalRatios = [0.50, 0.35, 0.10, 0.05];
      // Pillar focus (B): centre (pillar), sub ring (three subs), micro ring (nine micros)
    // Pillar focus: favour the centre and the ring of three subs.  We give
    // 55% to the centre, 35% to the sub ring and shrink the micro ring to
    // 10% of the radius.
    const bRatios = [0.55, 0.35, 0.10];
      // Sub focus (C): centre (sub) and micro ring (three micros)
    // Sub focus: emphasise the selected sub while leaving space for its three
    // micros.  In the spec we initially allocated 75% of the radius to the
    // centre and 25% to the micro ring.  Users requested more room for the
    // micro ring to avoid label overlap, so shrink the centre to 60% and
    // allocate 40% to the micro ring.
    const cRatios = [0.60, 0.40];
      const gap = 2; // small gap between rings
      // Compute radii for global state
      let cumulative = 0;
      const rA1 = radius * globalRatios[0];
      const rA2 = rA1 + radius * globalRatios[1];
      const rA3 = rA2 + radius * globalRatios[2];
      const globalRadii = {
        coreEnd: rA1 - gap,
        pillarStart: rA1,
        pillarEnd: rA2 - gap,
        subStart: rA2,
        subEnd: rA3 - gap,
        microStart: rA3,
        microEnd: radius
      };
      // Compute radii for pillar focus
      const bR1 = radius * bRatios[0];
      const bR2 = bR1 + radius * bRatios[1];
      const pillarRadii = {
        center: bR1 - gap,
        subStart: bR1,
        subEnd: bR2 - gap,
        microStart: bR2,
        microEnd: radius
      };
      // Compute radii for sub focus
      const cR1 = radius * cRatios[0];
      const subRadii = {
        center: cR1 - gap,
        microStart: cR1,
        microEnd: radius
      };
      return { A: globalRadii, B: pillarRadii, C: subRadii };
    }

    /**
     * Computes an array of arc descriptors representing all wedges to be drawn
     * in the current state.  Each descriptor contains angular and radial
     * boundaries, hierarchy indices (pillar/sub/micro) and associated beliefs.
     */
    function computeArcDescriptors() {
      const descriptors = [];
      const twoPi = Math.PI * 2;
      if (!aimData) return descriptors;
      // Compute radii and cache for flash effects
      currentRingRadii = computeRadii();
      const radii = currentRingRadii[currentState];
      if (currentState === 'A') {
        // Global view: draw all depth 1, 2 and 3 wedges
        const majorStep = twoPi / 3;        // 120° per pillar
        const subStep = majorStep / 3;       // 40° per sub
        const microStep = subStep / 3;       // 13.33° per micro
        // Pillars
        for (let p = 1; p <= 3; p++) {
          const start = (p - 1) * majorStep;
          const end = p * majorStep;
          const belief = aimData.pillars[p].belief;
          const title = aimData.pillars[p].title || belief;
          const conf = aimData.pillars[p].confidence || 50;
          // Use provided title if available; otherwise truncate belief for label
          const label = truncateText(title || belief, maxCharsByDepth[1]);
          descriptors.push({
            depth: 1,
            pillar: p,
            startAngle: start,
            endAngle: end,
            innerRadius: radii.pillarStart,
            outerRadius: radii.pillarEnd,
            belief: belief,
            label: label,
            confidence: conf,
            sub: null,
            micro: null,
            showLabel: true,
            pole_ac_value: aimData.pillars[p].pole_ac_value,
            pole_ac_letter: aimData.pillars[p].pole_ac_letter,
            pole_ce_value: aimData.pillars[p].pole_ce_value,
            pole_ce_letter: aimData.pillars[p].pole_ce_letter,
            pole_cx_value: aimData.pillars[p].pole_cx_value,
            pole_cx_letter: aimData.pillars[p].pole_cx_letter
          });
          // Subs
          for (let s = 1; s <= 3; s++) {
            const sStart = start + (s - 1) * subStep;
            const sEnd = sStart + subStep;
            const beliefSub = aimData.subs[p][s].belief;
            const titleSub = aimData.subs[p][s].title || beliefSub;
            const confSub = aimData.subs[p][s].confidence || 50;
            const labelSub = truncateText(titleSub || beliefSub, maxCharsByDepth[2]);
            descriptors.push({
              depth: 2,
              pillar: p,
              sub: s,
              startAngle: sStart,
              endAngle: sEnd,
              innerRadius: radii.subStart,
              outerRadius: radii.subEnd,
              belief: beliefSub,
              label: labelSub,
              confidence: confSub,
              micro: null,
            showLabel: false,
            pole_ac_value: aimData.subs[p][s].pole_ac_value,
            pole_ac_letter: aimData.subs[p][s].pole_ac_letter,
            pole_ce_value: aimData.subs[p][s].pole_ce_value,
            pole_ce_letter: aimData.subs[p][s].pole_ce_letter,
            pole_cx_value: aimData.subs[p][s].pole_cx_value,
            pole_cx_letter: aimData.subs[p][s].pole_cx_letter
            });
            // Micros
            for (let m = 1; m <= 3; m++) {
              const mStart = sStart + (m - 1) * microStep;
              const mEnd = mStart + microStep;
              const beliefMicro = aimData.micros[p][s][m].belief;
              const titleMicro = aimData.micros[p][s][m].title || beliefMicro;
              const confMicro = aimData.micros[p][s][m].confidence || 50;
              const labelMicro = truncateText(titleMicro || beliefMicro, maxCharsByDepth[3]);
              descriptors.push({
                depth: 3,
                pillar: p,
                sub: s,
                micro: m,
                startAngle: mStart,
                endAngle: mEnd,
                innerRadius: radii.microStart,
                outerRadius: radii.microEnd,
                belief: beliefMicro,
                label: labelMicro,
                confidence: confMicro,
                showLabel: false
                ,
                pole_ac_value: aimData.micros[p][s][m].pole_ac_value,
                pole_ac_letter: aimData.micros[p][s][m].pole_ac_letter,
                pole_ce_value: aimData.micros[p][s][m].pole_ce_value,
                pole_ce_letter: aimData.micros[p][s][m].pole_ce_letter,
                pole_cx_value: aimData.micros[p][s][m].pole_cx_value,
                pole_cx_letter: aimData.micros[p][s][m].pole_cx_letter
              });
            }
          }
        }
      } else if (currentState === 'B' && selectedPillar) {
        // Pillar focus: centre shows the pillar; one ring for its 3 subs; outer ring for its 9 micros
        const p = selectedPillar;
        // Sub and micro angles span full circle
        const subStep = twoPi / 3;         // 120° per sub (3 subs)
        const microStep = twoPi / 9;       // 40° per micro (9 micros)
        // Subs
        for (let s = 1; s <= 3; s++) {
          const sStart = (s - 1) * subStep;
          const sEnd = sStart + subStep;
          const beliefSub = aimData.subs[p][s].belief;
          const titleSub = aimData.subs[p][s].title || beliefSub;
          const confSub = aimData.subs[p][s].confidence || 50;
          const labelSub = truncateText(titleSub || beliefSub, maxCharsByDepth[2]);
          descriptors.push({
            depth: 2,
            pillar: p,
            sub: s,
            startAngle: sStart,
            endAngle: sEnd,
            innerRadius: radii.subStart,
            outerRadius: radii.subEnd,
            belief: beliefSub,
            label: labelSub,
            confidence: confSub,
            micro: null,
            showLabel: true,
            pole_ac_value: aimData.subs[p][s].pole_ac_value,
            pole_ac_letter: aimData.subs[p][s].pole_ac_letter,
            pole_ce_value: aimData.subs[p][s].pole_ce_value,
            pole_ce_letter: aimData.subs[p][s].pole_ce_letter,
            pole_cx_value: aimData.subs[p][s].pole_cx_value,
            pole_cx_letter: aimData.subs[p][s].pole_cx_letter
          });
          // Micros (3 per sub; repeated to make 9 arcs; no labels)
          for (let m = 1; m <= 3; m++) {
            for (let repeat = 0; repeat < 3; repeat++) {
              const idx = (s - 1) * 3 + (m - 1) * 3 + repeat;
              const mStart = idx * microStep;
              const mEnd = mStart + microStep;
              const beliefMicro = aimData.micros[p][s][m].belief;
              const titleMicro = aimData.micros[p][s][m].title || beliefMicro;
              const confMicro = aimData.micros[p][s][m].confidence || 50;
              const labelMicro = truncateText(titleMicro || beliefMicro, maxCharsByDepth[3]);
              descriptors.push({
                depth: 3,
                pillar: p,
                sub: s,
                micro: m,
                startAngle: mStart,
                endAngle: mEnd,
                innerRadius: radii.microStart,
                outerRadius: radii.microEnd,
                belief: beliefMicro,
                label: labelMicro,
                confidence: confMicro,
                showLabel: false,
                pole_ac_value: aimData.micros[p][s][m].pole_ac_value,
                pole_ac_letter: aimData.micros[p][s][m].pole_ac_letter,
                pole_ce_value: aimData.micros[p][s][m].pole_ce_value,
                pole_ce_letter: aimData.micros[p][s][m].pole_ce_letter,
                pole_cx_value: aimData.micros[p][s][m].pole_cx_value,
                pole_cx_letter: aimData.micros[p][s][m].pole_cx_letter
              });
            }
          }
        }
      } else if (currentState === 'C' && selectedPillar && selectedSub) {
        // Sub focus: centre shows selected sub; outer ring shows its 3 micros equally spaced
        const p = selectedPillar;
        const s = selectedSub;
        const microStep = twoPi / 3;
        for (let m = 1; m <= 3; m++) {
          const mStart = (m - 1) * microStep;
          const mEnd = mStart + microStep;
          const beliefMicro = aimData.micros[p][s][m].belief;
          const titleMicro = aimData.micros[p][s][m].title || beliefMicro;
          const confMicro = aimData.micros[p][s][m].confidence || 50;
          const labelMicro = truncateText(titleMicro || beliefMicro, maxCharsByDepth[3]);
          descriptors.push({
            depth: 3,
            pillar: p,
            sub: s,
            micro: m,
            startAngle: mStart,
            endAngle: mEnd,
            innerRadius: radii.microStart,
            outerRadius: radii.microEnd,
            belief: beliefMicro,
            label: labelMicro,
            confidence: confMicro,
            showLabel: true,
            pole_ac_value: aimData.micros[p][s][m].pole_ac_value,
            pole_ac_letter: aimData.micros[p][s][m].pole_ac_letter,
            pole_ce_value: aimData.micros[p][s][m].pole_ce_value,
            pole_ce_letter: aimData.micros[p][s][m].pole_ce_letter,
            pole_cx_value: aimData.micros[p][s][m].pole_cx_value,
            pole_cx_letter: aimData.micros[p][s][m].pole_cx_letter
          });
        }
      }
      return descriptors;
    }

    /**
     * Updates the chart by computing descriptors for the current state and
     * binding them to SVG paths.  This function also attaches event handlers
     * for hover and click interactions.  The arcs are keyed by a composite
     * string to ensure stable joins across updates.
     */
    function updateChart() {
      if (!aimData) return;
      // Compute descriptors for the current state; computeRadii() will update the SVG
      const descriptors = computeArcDescriptors();

      // Remove any existing groups; create group structure fresh
      svg.selectAll('*').remove();
      const g = svg.append('g')
        .attr('class','arcs')
        // centre the coordinate system based on the newly sized SVG
        .attr('transform', () => {
          const bbox = svg.node().getBoundingClientRect();
          return `translate(${bbox.width / 2},${bbox.height / 2})`;
        });
      // For accessibility, we attach a tabindex to each path if clickable
      const arcs = g.selectAll('path.wedge')
        .data(descriptors, d => `${d.depth}-${d.pillar}-${d.sub || 0}-${d.micro || 0}-${d.startAngle}`)
        .join('path')
        .attr('class','wedge')
        .attr('d', d => {
          return d3.arc()({
            innerRadius: d.innerRadius,
            outerRadius: d.outerRadius,
            startAngle: d.startAngle,
            endAngle: d.endAngle
          });
        })
        .attr('fill', d => computeFillColor(d))
        .attr('stroke', 'none')
        .attr('tabindex', d => {
          // Only make wedges focusable if they are clickable
          if (currentState === 'A' && (d.depth === 1 || d.depth === 2)) return 0;
          if (currentState === 'B' && d.depth === 2) return 0;
          return -1;
        })
        .style('cursor', d => {
          if (currentState === 'A' && (d.depth === 1 || d.depth === 2)) return 'pointer';
          if (currentState === 'B' && d.depth === 2) return 'pointer';
          return 'default';
        })
        .on('mouseover', function(event, d) {
          showTooltip(event, d);
          // Pulse legend chip for hovered wedge’s pillar
          highlightLegendChip(d.pillar);
        })
        .on('mousemove', function(event) {
          moveTooltip(event);
        })
        .on('mouseout', function(event, d) {
          hideTooltip();
          removeLegendHighlight();
        })
        .on('click', function(event, d) {
          event.preventDefault();
          handleArcClick(d);
        });
      // Add separators for current state
      drawSeparators(g);
      // Draw centre labels for States B and C
      drawCenterText(g);
      // Draw labels inside selected wedges
      drawArcLabels(g, descriptors);

      // Add an invisible disc over the centre to enable tooltips on the centre
      addCenterHover(g);

      // Update the lenses sidebar whenever the chart state changes.
      // Calling updateLenses here ensures the lens list and heading reflect
      // the currently selected pillar or remain unfiltered in the global view.
      updateLenses();
    }

    /**
     * Draws radial separators between wedges according to the current state.
     * Separators are implemented as SVG lines or paths with specified
     * strokes and opacities.  Major separators separate pillars, minor
     * separators separate subs and micro separators separate micros.
     */
    function drawSeparators(g) {
      const radii = currentRingRadii[currentState];
      const twoPi = Math.PI * 2;
      // Helper to convert polar coords to Cartesian
      const polarToCartesian = (angle, radius) => {
        const x = Math.cos(angle - Math.PI / 2) * radius;
        const y = Math.sin(angle - Math.PI / 2) * radius;
        return [x, y];
      };
      if (currentState === 'A') {
        const majorAngles = [0, 2 * Math.PI / 3, 4 * Math.PI / 3];
        const minorAngles = [];
        const microAngles = [];
        // Sub boundaries
        const subStep = (2 * Math.PI) / 3 / 3; // 40°
        for (let i = 0; i < 3; i++) {
          const base = i * (2 * Math.PI / 3);
          minorAngles.push(base + subStep);
          minorAngles.push(base + subStep * 2);
          // Micro boundaries within each sub
          const microStep = subStep / 3;
          for (let j = 0; j < 3; j++) {
            const microBase = base + j * subStep;
            microAngles.push(microBase + microStep);
            microAngles.push(microBase + microStep * 2);
          }
        }
        // Draw major separators from core to outermost
        majorAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.pillarStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.30)')
            .attr('stroke-width', 1.6);
        });
        // Minor separators from sub ring to outer ring
        minorAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.subStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.22)')
            .attr('stroke-width', 1.2);
        });
        // Micro separators from micro ring start to micro ring end
        microAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.microStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.18)')
            .attr('stroke-width', 1.0);
        });
      } else if (currentState === 'B') {
        // In pillar focus we draw separators between the 3 subs (120° each)
        // and between the 9 micro segments (40° each).  Include angle 0 so a
        // vertical line is visible at the top of the circle.
        const subStep = (2 * Math.PI) / 3;
        const microStep = (2 * Math.PI) / 9;
        const subAngles = [0, subStep, subStep * 2];
        const microAngles = [];
        for (let k = 0; k < 9; k++) {
          // Skip the full circle micro boundary at 2π (same as 0)
          const angle = microStep * k;
          microAngles.push(angle);
        }
        // Draw sub separators from sub ring start to outer ring end
        subAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.subStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.22)')
            .attr('stroke-width', 1.2);
        });
        // Draw micro separators from micro ring start to micro ring end
        microAngles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.microStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.18)')
            .attr('stroke-width', 1.0);
        });
      } else if (currentState === 'C') {
        // In sub focus we draw separators between the 3 micro wedges.  Include angle 0
        const microStep = (2 * Math.PI) / 3;
        const angles = [0, microStep, microStep * 2];
        angles.forEach(angle => {
          const [x0, y0] = polarToCartesian(angle, radii.microStart);
          const [x1, y1] = polarToCartesian(angle, radii.microEnd);
          g.append('line')
            .attr('x1', x0)
            .attr('y1', y0)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', 'rgba(0,0,0,0.18)')
            .attr('stroke-width', 1.0);
        });
      }
    }

    /**
     * Draws the centre text for the focus states.  In pillar focus (B) the
     * centre displays the selected pillar’s belief text.  In sub focus (C)
     * the centre displays the selected sub’s belief text and its parent
     * pillar name.  In global state (A) nothing is drawn in the centre.
     */
    function drawCenterText(g) {
      if (currentState === 'A') {
        // Global view: show a "Core" label followed by the truncated core belief (not title).
        const radii = currentRingRadii.A;
        const textGroup = g.append('g').attr('pointer-events','none');
        // Always use the core belief for the centre text
        const coreBelief = aimData.core.belief || '';
        const truncated = truncateText(coreBelief, centerBeliefMaxChars);
        const wrapLen = Math.max(8, Math.floor(radii.coreEnd / 8));
        const linesBelief = wrapLines(truncated, wrapLen);
        // Build array of lines: first the label, then the belief lines
        const lines = ['Core', ...linesBelief];
        // Compute font size relative to radius and number of lines
        const fontSize = Math.min(radii.coreEnd / (lines.length + 1), 18);
        const textEl = textGroup.append('text')
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('font-size', fontSize + 'px')
          .style('fill','#111');
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? -(lines.length - 1) / 2 * (fontSize + centerLineGap) : (fontSize + centerLineGap))
            .style('font-weight', i === 0 ? '700' : '400')
            .text(line);
        });
      } else if (currentState === 'B' && selectedPillar) {
        // Pillar focus: show the pillar name and truncated pillar belief.
        const radii = currentRingRadii.B;
        const textGroup = g.append('g').attr('pointer-events','none');
        const pillarLabel = aimData.pillarNames[selectedPillar] || '';
        // Always use the pillar belief (not title) in the centre
        const pillarBelief = aimData.pillars[selectedPillar].belief || '';
        const truncated = truncateText(pillarBelief, centerBeliefMaxChars);
        const wrapLen = Math.max(8, Math.floor(radii.center / 8));
        const linesBelief = wrapLines(truncated, wrapLen);
        const lines = [pillarLabel, ...linesBelief];
        const fontSize = Math.min(radii.center / (lines.length + 1), 18);
        const textEl = textGroup.append('text')
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('font-size', fontSize + 'px')
          .style('fill','#111');
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? -(lines.length - 1) / 2 * (fontSize + centerLineGap) : (fontSize + centerLineGap))
            .style('font-weight', i === 0 ? '700' : '400')
            .text(line);
        });
      } else if (currentState === 'C' && selectedPillar && selectedSub) {
        // Sub focus: show the sub title (if provided) and the truncated sub
        // belief underneath.  The title appears on the first line in bold.
        const radii = currentRingRadii.C;
        const textGroup = g.append('g').attr('pointer-events','none');
        // Title from the CSV (short label) if present
        const subTitle = aimData.subs[selectedPillar][selectedSub].title || '';
        // Use the sub belief for the body text
        const subBelief = aimData.subs[selectedPillar][selectedSub].belief || '';
        const truncated = truncateText(subBelief, centerBeliefMaxChars);
        const wrapLen = Math.max(8, Math.floor(radii.center / 8));
        const beliefLines = wrapLines(truncated, wrapLen);
        // Build an array combining title (if non‑empty) and belief lines
        const lines = [];
        if (subTitle) lines.push(subTitle);
        beliefLines.forEach(line => lines.push(line));
        // Compute font size relative to radius and number of lines
        const fontSize = Math.min(radii.center / (lines.length + 1), 18);
        const textEl = textGroup.append('text')
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('font-size', fontSize + 'px')
          .style('fill','#111');
        lines.forEach((line, i) => {
          textEl.append('tspan')
            .attr('x', 0)
            .attr('dy', i === 0 ? -(lines.length - 1) / 2 * (fontSize + centerLineGap) : (fontSize + centerLineGap))
            .style('font-weight', i === 0 && subTitle ? '700' : '400')
            .text(line);
        });
      }
    }

    /**
     * Simple text wrapping helper.  Splits a string into multiple lines
     * attempting to keep each line under maxLen characters.  Words are not
     * broken mid‑token.  If no spaces are present within a segment, the
     * overflow will simply spill onto the next line.
     *
     * @param {string} text The text to wrap
     * @param {number} maxLen Approximate maximum characters per line
     * @returns {string[]} Array of lines
     */
    function wrapLines(text, maxLen) {
      if (!text) return [''];
      const words = text.split(/\s+/);
      const lines = [];
      let current = '';
      words.forEach(word => {
        if (current.length > 0 && (current + ' ' + word).length > maxLen) {
          lines.push(current);
          current = word;
        } else {
          current = current.length > 0 ? current + ' ' + word : word;
        }
      });
      if (current.length > 0) lines.push(current);
      return lines;
    }

    /**
     * Truncates a string to a maximum number of characters, appending an
     * ellipsis when the original string exceeds that length.  Attempts
     * to avoid cutting a word mid‑token by truncating at the last
     * space within the limit where possible.
     *
     * @param {string} text The text to truncate
     * @param {number} maxChars Maximum characters to keep
     * @returns {string} The truncated text with ellipsis if needed
     */
    function truncateText(text, maxChars) {
      if (!text) return '';
      if (text.length <= maxChars) return text;
      let truncated = text.slice(0, maxChars);
      const lastSpace = truncated.lastIndexOf(' ');
      if (lastSpace > 5) {
        truncated = truncated.slice(0, lastSpace);
      }
      return truncated.trim() + '…';
    }

    /**
     * Handles clicks on wedges by updating the state machine.  Clicking on
     * pillars or subs in the global state zooms into the pillar focus.  A
     * subsequent click on a sub when in pillar focus zooms into the sub
     * focus.  Micros are not clickable.  The legend and chart are
     * re-rendered accordingly and a flash effect is triggered on the
     * appropriate ring.
     */
    function handleArcClick(d) {
      if (currentState === 'A') {
        if (d.depth === 1) {
          // Click on a pillar: go to pillar focus
          selectedPillar = d.pillar;
          selectedSub = null;
          preselectedSub = null;
          currentState = 'B';
          updateChart();
          updateLegend();
          // Flash sub ring
          setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
        } else if (d.depth === 2) {
          // Click on a sub: go to pillar focus with this sub preselected
          selectedPillar = d.pillar;
          selectedSub = null;
          preselectedSub = d.sub;
          currentState = 'B';
          updateChart();
          updateLegend();
          // Flash sub ring
          setTimeout(() => flashRing(currentRingRadii.B.subStart, currentRingRadii.B.subEnd), 0);
        }
      } else if (currentState === 'B' && d.pillar === selectedPillar) {
        if (d.depth === 2) {
          // If preselectedSub exists and matches, go directly to sub focus
          if (preselectedSub && preselectedSub === d.sub) {
            selectedSub = d.sub;
            currentState = 'C';
            preselectedSub = null;
            updateChart();
            updateLegend();
            // Flash micro ring in sub focus
            setTimeout(() => flashRing(currentRingRadii.C.microStart, currentRingRadii.C.microEnd), 0);
          } else {
            // If no preselection, go to sub focus directly
            selectedSub = d.sub;
            preselectedSub = null;
            currentState = 'C';
            updateChart();
            updateLegend();
            setTimeout(() => flashRing(currentRingRadii.C.microStart, currentRingRadii.C.microEnd), 0);
          }
        }
      }
    }

    /**
     * Draw labels inside wedges for those descriptors marked with showLabel.
     * Labels are centred at the centroid of each arc and are wrapped
     * heuristically based on character count and ring thickness.  No labels
     * are drawn for micros in state A/B or subs in state A.
     */
    function drawArcLabels(g, descriptors) {
      const labelDescs = descriptors.filter(d => d.showLabel);
      labelDescs.forEach(d => {
        // Compute centroid of the arc using d3.arc().centroid
        const arcGen = d3.arc();
        const centroid = arcGen.centroid(d);
        // Compute an approximate font size based on ring thickness
        const thickness = d.outerRadius - d.innerRadius;
        const fontSize = Math.min(thickness / 3, 16);
        // Estimate a character limit for each line based on the arc length.  The
        // arc length is approximated by the average radius multiplied by the
        // angular span.  Divide by ~8 pixels per character to get a rough
        // character count.  Clamp between 8 and 24 to avoid extremes.
        const arcLength = (d.endAngle - d.startAngle) * ((d.innerRadius + d.outerRadius) / 2);
        // Clamp between 8 and 16 characters.  Keeping lines shorter helps
        // prevent text spilling outside narrow wedges.
        const charLimit = Math.max(8, Math.min(16, Math.floor(arcLength / 8)));
        // Wrap the truncated label rather than the full belief.  This
        // prevents overflow and ensures ellipses are shown consistently.  If
        // d.label is empty, fall back to the belief.
        const baseText = d.label && d.label.trim().length > 0 ? d.label : d.belief;
        const lines = wrapLines(baseText, charLimit);
        const lineHeight = fontSize + 2;
        const text = g.append('text')
          .attr('transform', `translate(${centroid[0]},${centroid[1]})`)
          .attr('text-anchor','middle')
          .attr('dominant-baseline','middle')
          .style('pointer-events','none')
          .style('fill','#111')
          .style('font-size', fontSize + 'px');
        lines.forEach((line, i) => {
          text.append('tspan')
            .attr('x', 0)
            .attr('dy', (i === 0 ? -(lines.length - 1) / 2 * lineHeight : lineHeight))
            .text(line);
        });
      });
    }

    // Tab switching between AIM and Projects views.  When switching to
    // projects, update the projects list.  Only minimal styling is
    // applied; the active tab is indicated via CSS.
    const aimTabEl = document.getElementById('aimTab');
    const projectsTabEl = document.getElementById('projectsTab');
    const aimViewEl = document.getElementById('aimView');
    const projectsViewEl = document.getElementById('projectsView');
    if (aimTabEl && projectsTabEl && aimViewEl && projectsViewEl) {
      aimTabEl.addEventListener('click', () => {
        aimTabEl.classList.add('active');
        projectsTabEl.classList.remove('active');
        aimViewEl.style.display = '';
        projectsViewEl.style.display = 'none';
      });
      projectsTabEl.addEventListener('click', () => {
        projectsTabEl.classList.add('active');
        aimTabEl.classList.remove('active');
        aimViewEl.style.display = 'none';
        projectsViewEl.style.display = '';
        updateProjectsView();
      });
    }

    /**
     * Renders the projects view.  Shows up to three projects by default
     * and exposes a button to reveal more.  Each project card displays
     * key information such as the action name, measure, starting amount,
     * target, days per week, benefit, and priorities.  Collapsed details
     * can be toggled via a plus/minus button.
     */
    function updateProjectsView() {
      const listEl = document.getElementById('projectsList');
      const showMoreBtn = document.getElementById('showMoreProjectsBtn');
      if (!listEl) return;
      listEl.innerHTML = '';
      if (!aimData || !Array.isArray(aimData.projects) || aimData.projects.length === 0) {
        listEl.textContent = 'No projects.';
        if (showMoreBtn) showMoreBtn.style.display = 'none';
        return;
      }
      // Copy projects and sort them so that lower user priority values (e.g., P0)
      // appear first.  If the priority_user is missing, assign a high
      // numerical value.  This ensures P0 < P1 < P2, etc.  If neither
      // priority_user nor priority_ai are provided, the order remains as defined.
      const projects = aimData.projects.slice();
      function parsePriority(str) {
        if (!str) return Infinity;
        const m = /P(\d+)/i.exec(str.trim());
        return m ? parseInt(m[1], 10) : Infinity;
      }
      
      projects.sort((a, b) => {
        // Effective priority: use user priority if present; otherwise use machine (AI) priority.
        const upA = parsePriority(a.priority_user);
        const aiA = parsePriority(a.priority_ai);
        const effA = Number.isFinite(upA) ? upA : aiA;

        const upB = parsePriority(b.priority_user);
        const aiB = parsePriority(b.priority_ai);
        const effB = Number.isFinite(upB) ? upB : aiB;

        if (effA !== effB) return effA - effB;
        // Tie-break: preserve original order
        return aimData.projects.indexOf(a) - aimData.projects.indexOf(b);
      });
    
      const maxInitial = 3;
      const initial = projects.slice(0, maxInitial);
      const remaining = projects.slice(maxInitial);
      // Helper to create a project card.  Projects can be either practice or sprint
      // type.  Practice projects show measure/start/target/days fields, while
      // sprint projects show a duration field instead.  Each card header also
      // includes a type badge ("Practice" or "Sprint").
      function createProjectCard(pObj) {
        const card = document.createElement('div');
        card.style.border = '1px solid #cccccc';
        card.style.borderRadius = '6px';
        card.style.padding = '8px';
        card.style.background = '#fafafa';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.gap = '4px';
        // Header row includes project name and edit button
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.justifyContent = 'space-between';
        // Project title
        const titleEl = document.createElement('span');
        titleEl.style.fontWeight = '600';
        titleEl.style.fontSize = '1rem';
        titleEl.textContent = pObj.action || pObj.outcome || pObj.benefit || '(Unnamed project)';
        // Type badge: display either Practice or Sprint based on project_type (default to Practice)
        const typeLabel = document.createElement('span');
        typeLabel.style.fontSize = '0.7rem';
        typeLabel.style.fontWeight = '600';
        typeLabel.style.padding = '2px 6px';
        typeLabel.style.borderRadius = '4px';
        typeLabel.style.backgroundColor = '#e0e0e0';
        // fixed width to align badges across cards
        typeLabel.style.minWidth = '58px';
        typeLabel.style.textAlign = 'center';
        const pType = (pObj.type || '').toLowerCase();
        const displayType = pType === 'sprint' ? 'Sprint' : 'Practice';
        typeLabel.textContent = displayType;
        // Edit pencil button: clicking enters inline edit mode for this project
        const editBtn = document.createElement('button');
        editBtn.className = 'iconButton';
        editBtn.style.width = '24px';
        editBtn.style.height = '24px';
        editBtn.style.marginLeft = '4px';
        editBtn.title = 'Edit project';
        // Insert pencil SVG icon
        editBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M3 17.25V21h3.75l11.06-11.06-3.75-3.75L3 17.25zM20.71 7.04a1.003 1.003 0 0 0 0-1.42l-2.34-2.34a1.003 1.003 0 0 0-1.42 0l-1.83 1.83 3.75 3.75 1.84-1.82z" fill="currentColor"/></svg>`;
        // Determine original index of this project in aimData.projects
        const origIndex = aimData.projects.indexOf(pObj);
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          // Inline editing: convert this card into an editable form
          startProjectInlineEdit(card, pObj, origIndex);
        });
        // Create a right section to hold the type label and pencil, aligning them together
        const rightSection = document.createElement('div');
        rightSection.style.display = 'flex';
        rightSection.style.alignItems = 'center';
        rightSection.style.gap = '6px';
        rightSection.appendChild(typeLabel);
        rightSection.appendChild(editBtn);
        // Build header with two items: title on left, rightSection on right
        header.appendChild(titleEl);
        header.appendChild(rightSection);
        card.appendChild(header);
        // Summary line: show outcome/benefit and user priority.  The project type is indicated via the badge on the right, so we omit it here.
        const summary = document.createElement('div');
        summary.style.fontSize = '0.85rem';
        const parts = [];
        if (pObj.outcome) parts.push(`Outcome: ${pObj.outcome}`);
        else if (pObj.benefit) parts.push(`Benefit: ${pObj.benefit}`);
        if (pObj.priority_user) parts.push(`User priority: ${pObj.priority_user}`);
        summary.textContent = parts.join(' | ');
        card.appendChild(summary);
        // Details container with other fields.  For practice projects, display
        // measure, start, target and days/week.  For sprint projects, display
        // duration instead of practice fields.
        const details = document.createElement('div');
        details.style.fontSize = '0.8rem';
        details.style.marginTop = '4px';
        details.style.display = 'none';
        let detailsHtml = '';
        // Today and details
        if (pObj.today_state) detailsHtml += `<div><strong>Today:</strong> ${pObj.today_state}</div>`;
        if (pObj.details) detailsHtml += `<div><strong>Details:</strong> ${pObj.details}</div>`;
        // Outcome, acceptance, reference
        if (pObj.outcome) detailsHtml += `<div><strong>Outcome:</strong> ${pObj.outcome}</div>`;
        if (pObj.acceptance) detailsHtml += `<div><strong>Acceptance:</strong> ${pObj.acceptance}</div>`;
        if (pObj.ref) detailsHtml += `<div><strong>Ref:</strong> ${pObj.ref}</div>`;
        // Benefit
        if (pObj.benefit) detailsHtml += `<div><strong>Benefit:</strong> ${pObj.benefit}</div>`;
        // Priorities
        if (pObj.priority_user) detailsHtml += `<div><strong>User priority:</strong> ${pObj.priority_user}</div>`;
        if (pObj.priority_ai) detailsHtml += `<div><strong>AI priority:</strong> ${pObj.priority_ai}</div>`;
        // Action/measure and other numeric fields
        // Display practice fields only if this is a practice project
        const isSprint = (pObj.type || '').toLowerCase() === 'sprint';
        if (!isSprint) {
          if (pObj.action && pObj.measure) detailsHtml += `<div><strong>Measure:</strong> ${pObj.measure}</div>`;
          if (pObj.start !== null && pObj.start !== undefined && String(pObj.start).trim() !== '') detailsHtml += `<div><strong>Start:</strong> ${pObj.start}</div>`;
          if (pObj.target !== null && pObj.target !== undefined && String(pObj.target).trim() !== '') detailsHtml += `<div><strong>Target:</strong> ${pObj.target}</div>`;
          if (pObj.days !== null && pObj.days !== undefined && String(pObj.days).trim() !== '') detailsHtml += `<div><strong>Days/week:</strong> ${pObj.days}</div>`;
        } else {
          // Sprint projects show duration instead of practice fields
          if (pObj.duration) detailsHtml += `<div><strong>Duration:</strong> ${pObj.duration}</div>`;
        }
        if (detailsHtml) details.innerHTML = detailsHtml;
        if (detailsHtml) card.appendChild(details);
        // Toggle button to show/hide details
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'iconButton';
        toggleBtn.style.width = '24px';
        toggleBtn.style.height = '24px';
        toggleBtn.textContent = '+';
        toggleBtn.addEventListener('click', () => {
          if (details && details.style.display === 'none') {
            details.style.display = '';
            toggleBtn.textContent = '–';
          } else {
            if (details) details.style.display = 'none';
            toggleBtn.textContent = '+';
          }
        });
        card.appendChild(toggleBtn);
        return card;
      }
      // Render initial projects
      initial.forEach(p => {
        const card = createProjectCard(p);
        listEl.appendChild(card);
      });
      // Setup show more/less buttons
      const showLessBtn = document.getElementById('showLessProjectsBtn');
      if (showMoreBtn && showLessBtn) {
        if (remaining.length > 0) {
          showMoreBtn.style.display = '';
          showLessBtn.style.display = 'none';
          showMoreBtn.onclick = () => {
            // Render the remaining projects
            remaining.forEach(p => {
              const card = createProjectCard(p);
              listEl.appendChild(card);
            });
            showMoreBtn.style.display = 'none';
            showLessBtn.style.display = '';
          };
          showLessBtn.onclick = () => {
            // Re-render collapsed view
            updateProjectsView();
            // After re-rendering, hide showLess and show showMore
          };
        } else {
          showMoreBtn.style.display = 'none';
          showLessBtn.style.display = 'none';
        }
      }
    }

    /**
     * Adds an invisible disc over the centre of the chart so that the
     * core/pillar/sub belief can show a tooltip on hover.  The disc’s
     * radius is derived from the current state’s centre radius.  The
     * tooltip displays the full belief text along with its breadcrumb
     * path.  Without this overlay the centre belief has no interactive
     * element to trigger a tooltip.
     *
     * @param {Object} g D3 selection of the current SVG group
     */
    function addCenterHover(g) {
      if (!aimData) return;
      let radius = 0;
      if (currentState === 'A') {
        radius = currentRingRadii.A.coreEnd;
      } else if (currentState === 'B') {
        radius = currentRingRadii.B.center;
      } else if (currentState === 'C') {
        radius = currentRingRadii.C.center;
      }
      if (radius <= 0) return;
      // Determine the descriptor for the centre based on the state
      function getCenterDescriptor() {
        if (currentState === 'A') {
          return { belief: aimData.core.belief || '', pillar: null, sub: null, micro: null };
        } else if (currentState === 'B' && selectedPillar) {
          return { belief: aimData.pillars[selectedPillar].belief || '', pillar: selectedPillar, sub: null, micro: null };
        } else if (currentState === 'C' && selectedPillar && selectedSub) {
          return { belief: aimData.subs[selectedPillar][selectedSub].belief || '', pillar: selectedPillar, sub: selectedSub, micro: null };
        }
        return { belief: '', pillar: null, sub: null, micro: null };
      }
      g.append('circle')
        .attr('r', radius)
        .attr('fill', 'transparent')
        .attr('pointer-events', 'all')
        .on('mouseover', function(event) {
          const desc = getCenterDescriptor();
          showTooltip(event, desc);
        })
        .on('mousemove', function(event) {
          moveTooltip(event);
        })
        .on('mouseout', function() {
          hideTooltip();
        });
    }

    /**
     * Shows the tooltip near the pointer with the belief text and breadcrumb.
     */
    function showTooltip(event, d) {
      if (!d || !aimData) return;
      tooltip.style('display','block');
      let html = '';
      // Determine if this is a lens tooltip by checking for a pillars array and absence of hierarchical indices
      const isLens = d.hasOwnProperty('pillars') && !d.hasOwnProperty('pillar');
      if (isLens) {
        // Lens tooltip: show full lens text, pillar attachments and details in a structured layout
        const lensText = d.belief || '';
        html += `<div style="font-size:15px; font-weight:600; margin-bottom:4px;">${lensText}</div>`;
        // Associated pillars names
        if (Array.isArray(d.pillars) && d.pillars.length > 0) {
          const names = d.pillars.map(idx => aimData.pillarNames[idx] || '').filter(s => s);
          if (names.length > 0) {
            html += `<div style="font-size:12px; color:#555; margin-bottom:2px;">↳ Applies to: ${names.join(', ')}</div>`;
          }
        }
        // Collect numeric alignment and label values
        const confVal = (typeof d.confidence === 'number' && !isNaN(d.confidence)) ? d.confidence : null;
        const alignLabel = (confVal !== null) ? getAlignmentLabel(confVal) : '';
        // Determine pole phrases: use provided labels if available; otherwise compute from value/letter
        const acPhrase = d.pole_ac_label && d.pole_ac_label !== '' ? d.pole_ac_label : getPolePhrase(d.pole_ac_value, d.pole_ac_letter, 'ac');
        const cePhrase = d.pole_ce_label && d.pole_ce_label !== '' ? d.pole_ce_label : getPolePhrase(d.pole_ce_value, d.pole_ce_letter, 'ce');
        const cxPhrase = d.pole_cx_label && d.pole_cx_label !== '' ? d.pole_cx_label : getPolePhrase(d.pole_cx_value, d.pole_cx_letter, 'cx');
        // Determine whether to show each row: show if there is a score, letter, or explicit label.
        const hasAc = (d.pole_ac_value !== null && d.pole_ac_value !== undefined) || (d.pole_ac_letter) || (d.pole_ac_label && d.pole_ac_label !== '');
        const hasCe = (d.pole_ce_value !== null && d.pole_ce_value !== undefined) || (d.pole_ce_letter) || (d.pole_ce_label && d.pole_ce_label !== '');
        const hasCx = (d.pole_cx_value !== null && d.pole_cx_value !== undefined) || (d.pole_cx_letter) || (d.pole_cx_label && d.pole_cx_label !== '');
        // Format last updated
        let lastUpd = '';
        if (d.updated) {
          const formatted = formatDateString(d.updated);
          if (formatted) lastUpd = formatted;
        }
        // Build a small table for the metadata for readability
        html += `<div style="margin-top:4px; font-size:11.5px; color:#555;">
        <table style="border-collapse:collapse; width:100%;">
          ${confVal !== null ? `<tr><td style="padding:0 4px 2px 0;">Alignment:</td><td style="padding:0 0 2px 0; text-align:right;">${alignLabel} (${confVal}%)</td></tr>` : ''}
          ${hasAc ? `<tr><td style="padding:0 4px 2px 0;">Adaptive:</td><td style="padding:0 0 2px 0; text-align:right;">${acPhrase || 'balanced'}</td></tr>` : ''}
          ${hasCe ? `<tr><td style="padding:0 4px 2px 0;">Celebration:</td><td style="padding:0 0 2px 0; text-align:right;">${cePhrase || 'balanced'}</td></tr>` : ''}
          ${hasCx ? `<tr><td style="padding:0 4px 2px 0;">Collective experience:</td><td style="padding:0 0 2px 0; text-align:right;">${cxPhrase || 'balanced'}</td></tr>` : ''}
          ${lastUpd ? `<tr><td style="padding:0 4px 0 0;">Last updated:</td><td style="padding:0; text-align:right;">${lastUpd}</td></tr>` : ''}
        </table>
        </div>`;
        // Editing disabled in lens tooltips
      } else {
        // Arc tooltip: show the hovered belief and its parent only
        // Determine current and parent levels
        let currentLabel = 'Core';
        let currentText = aimData.core.belief || '';
        let parentLabel = '';
        let parentText = '';
        let confValue = 50;
        if (d.micro) {
          currentLabel = 'Micro';
          currentText = aimData.micros[d.pillar][d.sub][d.micro].belief || '';
          parentLabel = 'Sub';
          parentText = aimData.subs[d.pillar][d.sub].belief || '';
          confValue = aimData.micros[d.pillar][d.sub][d.micro].confidence || 50;
        } else if (d.sub) {
          currentLabel = 'Sub';
          currentText = aimData.subs[d.pillar][d.sub].belief || '';
          parentLabel = 'Pillar';
          parentText = aimData.pillars[d.pillar].belief || '';
          confValue = aimData.subs[d.pillar][d.sub].confidence || 50;
        } else if (d.pillar) {
          currentLabel = 'Pillar';
          currentText = aimData.pillars[d.pillar].belief || '';
          parentLabel = 'Core';
          parentText = aimData.core.belief || '';
          confValue = aimData.pillars[d.pillar].confidence || 50;
        } else {
          // Core belief
          currentLabel = 'Core';
          currentText = aimData.core.belief || '';
          parentLabel = '';
          parentText = '';
          confValue = aimData.core.confidence || 50;
        }
        // Build HTML with larger font for hovered item
        html += `<div style="font-size:18px; font-weight:700; margin-bottom:4px;">`;
        if (currentLabel) {
          html += `<strong>${currentLabel}:</strong> `;
        }
        html += `${currentText}</div>`;
        if (parentText) {
          // include an arrow to visually indicate support relationship
          html += `<div style="font-size:14px; color:#555;">↳ <strong>${parentLabel}:</strong> ${parentText}</div>`;
        }
        // Gather metadata for the current item
        let curObj;
        if (d.micro) {
          curObj = aimData.micros[d.pillar][d.sub][d.micro];
        } else if (d.sub) {
          curObj = aimData.subs[d.pillar][d.sub];
        } else if (d.pillar) {
          curObj = aimData.pillars[d.pillar];
        } else {
          curObj = aimData.core;
        }
        const curConf = curObj && typeof curObj.confidence === 'number' ? curObj.confidence : null;
        const curAlignLabel = curConf !== null ? getAlignmentLabel(curConf) : '';
        const acLab = curObj && curObj.pole_ac_label && curObj.pole_ac_label !== '' ? curObj.pole_ac_label : getPolePhrase(curObj.pole_ac_value, curObj.pole_ac_letter, 'ac');
        const ceLab = curObj && curObj.pole_ce_label && curObj.pole_ce_label !== '' ? curObj.pole_ce_label : getPolePhrase(curObj.pole_ce_value, curObj.pole_ce_letter, 'ce');
        const cxLab = curObj && curObj.pole_cx_label && curObj.pole_cx_label !== '' ? curObj.pole_cx_label : getPolePhrase(curObj.pole_cx_value, curObj.pole_cx_letter, 'cx');
        // Determine whether to show each row for the current belief.
        const hasAcArc = curObj && ((curObj.pole_ac_value !== null && curObj.pole_ac_value !== undefined) || curObj.pole_ac_letter || (curObj.pole_ac_label && curObj.pole_ac_label !== ''));
        const hasCeArc = curObj && ((curObj.pole_ce_value !== null && curObj.pole_ce_value !== undefined) || curObj.pole_ce_letter || (curObj.pole_ce_label && curObj.pole_ce_label !== ''));
        const hasCxArc = curObj && ((curObj.pole_cx_value !== null && curObj.pole_cx_value !== undefined) || curObj.pole_cx_letter || (curObj.pole_cx_label && curObj.pole_cx_label !== ''));
        const upd = curObj && curObj.updated ? formatDateString(curObj.updated) : '';
        // Build metadata table
        html += `<div style="border-top:1px solid #e0e0e0; padding-top:4px; margin-top:6px; font-size:11.5px; color:#555;"><table style="border-collapse:collapse; width:100%;">
          ${curConf !== null ? `<tr><td style="padding:0 4px 2px 0;">Alignment:</td><td style="padding:0 0 2px 0; text-align:right;">${curAlignLabel} (${curConf}%)</td></tr>` : ''}
          ${hasAcArc ? `<tr><td style="padding:0 4px 2px 0;">Adaptive:</td><td style="padding:0 0 2px 0; text-align:right;">${acLab || 'balanced'}</td></tr>` : ''}
          ${hasCeArc ? `<tr><td style="padding:0 4px 2px 0;">Celebration:</td><td style="padding:0 0 2px 0; text-align:right;">${ceLab || 'balanced'}</td></tr>` : ''}
          ${hasCxArc ? `<tr><td style="padding:0 4px 2px 0;">Collective experience:</td><td style="padding:0 0 2px 0; text-align:right;">${cxLab || 'balanced'}</td></tr>` : ''}
          ${upd ? `<tr><td style="padding:0 4px 0 0;">Last updated:</td><td style="padding:0; text-align:right;">${upd}</td></tr>` : ''}
        </table></div>`;
        // Editing disabled in belief tooltips
      }
      tooltip.html(html);
      moveTooltip(event);
    }

    /**
     * Moves the tooltip relative to the pointer position and clamps it to the
     * viewport.  This helper is called on mousemove.
     */
    function moveTooltip(event) {
      const tooltipNode = tooltip.node();
      const padding = 12;
      const tooltipRect = tooltipNode.getBoundingClientRect();
      let x = event.clientX + 14;
      let y = event.clientY + 14;
      const viewportWidth = document.documentElement.clientWidth;
      const viewportHeight = document.documentElement.clientHeight;
      // Clamp horizontally
      if (x + tooltipRect.width + padding > viewportWidth) {
        x = viewportWidth - tooltipRect.width - padding;
      }
      // Clamp vertically
      if (y + tooltipRect.height + padding > viewportHeight) {
        y = viewportHeight - tooltipRect.height - padding;
      }
      tooltip.style('left', x + 'px').style('top', y + 'px');
    }

    /** Hides the tooltip. */
    function hideTooltip() {
      tooltip.style('display','none');
    }

    // Tooltip edit handler: listen for clicks on the pencil icons within the tooltip.
    // This allows users to open the data view and edit the corresponding belief or lens directly.
    const tooltipDom = tooltip.node();
    if (tooltipDom) {
      tooltipDom.addEventListener('click', (event) => {
        const btn = event.target.closest('.tooltipEditButton');
        if (!btn) return;
        // Determine type (lens or belief) and indices from data attributes
        const type = btn.getAttribute('data-type');
        if (!type) return;
        // Ensure editing is enabled and show table overlay
        if (!editingEnabled) {
          editingEnabled = true;
          // Show edit note
          editNote.style.display = 'block';
        }
        // Open the table overlay if not already visible
        if (tableOverlay.style.display !== 'flex') {
          // show the overlay and set active tab
          tableOverlay.style.display = 'flex';
        }
        // Determine which data tab to open (beliefs tab for lenses and beliefs; projects tab for projects)
        // For beliefs and lenses, switch to AIM tab
        currentDataTab = 'aim';
        showDataTab('aim');
        // Rebuild tables to ensure editing fields are enabled
        buildTableView();
        buildProjectsTableView();
        // Identify the row to highlight
        let matchRowSelector = null;
        if (type === 'lens') {
          const lensIdx = btn.getAttribute('data-index');
          if (lensIdx !== null && lensIdx !== '') {
            matchRowSelector = `tr[data-depth="Lens"][data-lensIndex="${lensIdx}"]`;
          }
        } else {
          // belief: use data-pill, data-sub, data-micro attributes
          const p = btn.getAttribute('data-pill') || '';
          const s = btn.getAttribute('data-sub') || '';
          const m = btn.getAttribute('data-micro') || '';
          // Build selector that matches row attributes
          matchRowSelector = `tr[data-depth][data-pillar="${p ? aimData.pillarNames[p] || '' : ''}"]`;
          // For sub rows, dataset.pillar is name; dataset.depth is 'Sub', dataset.micro or dataset.sub not stored; we cannot easily match sub or micro names here.
          // Therefore search by pillar name only. We'll highlight the first matching row.
        }
        // Highlight the matching row if found
        if (matchRowSelector) {
          setTimeout(() => {
            const row = tableBody.querySelector(matchRowSelector);
            if (row) {
              // Add highlight class
              row.style.backgroundColor = '#fffdd0';
              // Scroll into view
              row.scrollIntoView({ block: 'center' });
              // Remove highlight after a delay
              setTimeout(() => {
                row.style.backgroundColor = '';
              }, 2000);
            }
          }, 50);
        }
      });
    }

    /**
     * Highlights the legend chip belonging to the given pillar index by
     * temporarily outlining it.  This is used on hover to pulse the chip.
     */
    function highlightLegendChip(pillarIdx) {
      legendContainer.selectAll('.legend-chip').classed('hovered', d => d === pillarIdx);
      // Add outline style via inline border; removed on mouseout
      legendContainer.selectAll('.legend-chip').each(function(d) {
        const chip = d3.select(this);
        if (d === pillarIdx) {
          chip.select('.dot').style('outline', `2px solid rgba(${pillarBases[d-1][0]},${pillarBases[d-1][1]},${pillarBases[d-1][2]},1)`);
        }
      });
    }
    /**
     * Removes any temporary highlight from legend chips.
     */
    function removeLegendHighlight() {
      legendContainer.selectAll('.legend-chip .dot').style('outline', 'none');
    }

    /**
     * Creates a quick flash on the destination ring to confirm navigation.  A
     * translucent ring is drawn and faded out.  The ring is defined by its
     * inner and outer radii.  This helper schedules its own removal.
     */
    function flashRing(innerR, outerR) {
      const g = svg.select('g.arcs');
      if (g.empty()) return;
      const path = d3.arc()({
        innerRadius: innerR,
        outerRadius: outerR,
        startAngle: 0,
        endAngle: Math.PI * 2
      });
      const flash = g.append('path')
        .attr('d', path)
        .attr('fill', 'rgba(255,255,255,0.3)')
        .attr('pointer-events','none');
      flash.transition()
        .duration(150)
        .attr('fill', 'rgba(255,255,255,0)')
        .remove();
    }

    /**
     * Builds the table view overlay showing all nodes with their hierarchical
     * coordinates.  The table is sorted by depth and then pillar/sub/micro.
     */
    function buildTableView() {
      if (!aimData) return;
      // Flatten nodes into an array for the table
      const rows = [];
      // Core
      rows.push({ depth: 0, pillar: '', sub: '', micro: '', label: 'Core', title: aimData.core.title || '', belief: aimData.core.belief || '', confidence: aimData.core.confidence || 50, updated: aimData.core.updated || '' });
      for (let p = 1; p <= 3; p++) {
        // Pillar with confidence
        rows.push({ depth: 1, pillar: p, sub: '', micro: '', label: aimData.pillarNames[p] || '', title: aimData.pillars[p].title || '', belief: aimData.pillars[p].belief || '', confidence: aimData.pillars[p].confidence || 50, updated: aimData.pillars[p].updated || '' });
        for (let s = 1; s <= 3; s++) {
          // Sub with confidence
          rows.push({ depth: 2, pillar: p, sub: s, micro: '', label: '', title: aimData.subs[p][s].title || '', belief: aimData.subs[p][s].belief || '', confidence: aimData.subs[p][s].confidence || 50, updated: aimData.subs[p][s].updated || '' });
          for (let m = 1; m <= 3; m++) {
            // Micro with confidence
            rows.push({ depth: 3, pillar: p, sub: s, micro: m, label: '', title: aimData.micros[p][s][m].title || '', belief: aimData.micros[p][s][m].belief || '', confidence: aimData.micros[p][s][m].confidence || 50, updated: aimData.micros[p][s][m].updated || '' });
          }
        }
      }
      // Append lens rows before sorting so that they are included in the
      // ordering.  Each lens row uses a depth value of 4 so that it sorts
      // after micros and includes its belief, confidence and pillar names.
      if (aimData.lenses && aimData.lenses.length > 0) {
        aimData.lenses.forEach((lensObj, idx) => {
          const names = Array.isArray(lensObj.pillars)
            ? lensObj.pillars.map(p => aimData.pillarNames[p] || '').filter(Boolean)
            : [];
          rows.push({ depth: 4, pillar: '', sub: '', micro: '', label: `Lens ${idx + 1}`, title: lensObj.title || '', belief: lensObj.belief || '', confidence: lensObj.confidence !== undefined ? lensObj.confidence : '', updated: lensObj.updated || '', applies: names.join(', '), lensIndex: idx });
        });
      }
      // Sort by depth then pillar/sub/micro so that lens rows appear last
      rows.sort((a,b) => {
        if (a.depth !== b.depth) return a.depth - b.depth;
        if (a.pillar !== b.pillar) return (a.pillar || 0) - (b.pillar || 0);
        if (a.sub !== b.sub) return (a.sub || 0) - (b.sub || 0);
        if (a.micro !== b.micro) return (a.micro || 0) - (b.micro || 0);
        return 0;
      });
      // Populate table body with twelve columns:
      // Depth, Pillar, Sub, Micro, Title, Belief, Confidence, Last updated,
      // Adaptive (poll), Celebration (poll), Collective (poll), Applies to
      tableBody.innerHTML = '';
      // Build filter options: gather unique pillar names and lens titles
      const filterSelect = document.getElementById('tableFilterSelect');
      if (filterSelect) {
        // Clear existing options except the first (All entries)
        while (filterSelect.options.length > 1) filterSelect.remove(1);
      }
      const filterValues = new Set();
      rows.forEach(r => {
        // Determine display names for depth and indices
        let displayDepth = '';
        switch (r.depth) {
          case 0: displayDepth = 'Core'; break;
          case 1: displayDepth = 'Pillar'; break;
          case 2: displayDepth = 'Sub'; break;
          case 3: displayDepth = 'Micro'; break;
          case 4: displayDepth = 'Lens'; break;
          default: displayDepth = r.depth;
        }
        // Pillar name or empty
        let displayPillar = '';
        if (r.depth !== 4 && r.pillar) {
          displayPillar = aimData.pillarNames[r.pillar] || '';
          filterValues.add(displayPillar);
        }
        // Sub title if available
        let displaySub = '';
        if (r.depth === 2 || r.depth === 3) {
          if (r.pillar && r.sub) {
            const obj = aimData.subs[r.pillar] && aimData.subs[r.pillar][r.sub];
            if (obj && obj.title) displaySub = obj.title;
          }
        }
        // Micro title if available
        let displayMicro = '';
        if (r.depth === 3) {
          if (r.pillar && r.sub && r.micro) {
            const obj = aimData.micros[r.pillar] && aimData.micros[r.pillar][r.sub] && aimData.micros[r.pillar][r.sub][r.micro];
            if (obj && obj.title) displayMicro = obj.title;
          }
        }
        // Compute alignment label (category) from confidence if numeric
        let alignCell = '';
        if (typeof r.confidence === 'number' && !isNaN(r.confidence)) {
          alignCell = getAlignmentLabel(r.confidence);
        } else if (r.confidence !== undefined && r.confidence !== '') {
          alignCell = r.confidence;
        }
        // Format updated date
        let updatedCell = '';
        if (r.updated) {
          updatedCell = formatDateString(r.updated) || '';
        }
        // Applies text
        const appliesText = (r.applies !== undefined ? r.applies : '');
        // Lookup today and details values for this row.
        let todayCell = '';
        let detailsCell = '';
        if (r.depth === 0) {
          todayCell = aimData.core.today_state || '';
          detailsCell = aimData.core.details || '';
        } else if (r.depth === 1) {
          const p = r.pillar;
          if (aimData.pillars[p]) {
            todayCell = aimData.pillars[p].today_state || '';
            detailsCell = aimData.pillars[p].details || '';
          }
        } else if (r.depth === 2) {
          const p = r.pillar;
          const s = r.sub;
          if (aimData.subs[p] && aimData.subs[p][s]) {
            todayCell = aimData.subs[p][s].today_state || '';
            detailsCell = aimData.subs[p][s].details || '';
          }
        } else if (r.depth === 3) {
          const p = r.pillar;
          const s = r.sub;
          const m = r.micro;
          if (aimData.micros[p] && aimData.micros[p][s] && aimData.micros[p][s][m]) {
            todayCell = aimData.micros[p][s][m].today_state || '';
            detailsCell = aimData.micros[p][s][m].details || '';
          }
        } else if (r.depth === 4) {
          const lensObj = aimData.lenses[r.lensIndex];
          if (lensObj) {
            todayCell = lensObj.today_state || '';
            detailsCell = lensObj.details || '';
          }
        }
        // Compute segmentation pole phrases or use provided labels.
        let adaptiveCell = '';
        let celebrationCell = '';
        let collectiveCell = '';
        // Helper to compute a phrase: use explicit label if provided; otherwise compute using getPolePhrase.
        function computePhrase(obj, type) {
          if (!obj) return '';
          let lbl;
          if (type === 'ac') lbl = obj.pole_ac_label;
          else if (type === 'ce') lbl = obj.pole_ce_label;
          else if (type === 'cx') lbl = obj.pole_cx_label;
          if (lbl && lbl !== '') return lbl;
          // Otherwise compute phrase from value/letter
          const val = type === 'ac' ? obj.pole_ac_value : type === 'ce' ? obj.pole_ce_value : obj.pole_cx_value;
          const lettr = type === 'ac' ? obj.pole_ac_letter : type === 'ce' ? obj.pole_ce_letter : obj.pole_cx_letter;
          // Determine orientation letter; if missing, use the default right‑side letter for this pole
          let letterForPhrase = lettr;
          if (!letterForPhrase || letterForPhrase === '') {
            const defaults = { ac: 'G', ce: 'P', cx: 'S' };
            letterForPhrase = defaults[type] || '';
          }
          const phrase = getPolePhrase(val, letterForPhrase, type);
          if (phrase && phrase.trim() !== '') return phrase;
          // If value exists but phrase empty, default to balanced
          if (val !== null && val !== undefined) return 'balanced';
          return '';
        }
        if (r.depth === 0) {
          // core
          adaptiveCell = computePhrase(aimData.core, 'ac');
          celebrationCell = computePhrase(aimData.core, 'ce');
          collectiveCell = computePhrase(aimData.core, 'cx');
        } else if (r.depth === 1) {
          const p = r.pillar;
          if (aimData.pillars[p]) {
            const obj = aimData.pillars[p];
            adaptiveCell = computePhrase(obj, 'ac');
            celebrationCell = computePhrase(obj, 'ce');
            collectiveCell = computePhrase(obj, 'cx');
          }
        } else if (r.depth === 2) {
          const p = r.pillar;
          const s = r.sub;
          if (aimData.subs[p] && aimData.subs[p][s]) {
            const obj = aimData.subs[p][s];
            adaptiveCell = computePhrase(obj, 'ac');
            celebrationCell = computePhrase(obj, 'ce');
            collectiveCell = computePhrase(obj, 'cx');
          }
        } else if (r.depth === 3) {
          const p = r.pillar;
          const s = r.sub;
          const m = r.micro;
          if (aimData.micros[p] && aimData.micros[p][s] && aimData.micros[p][s][m]) {
            const obj = aimData.micros[p][s][m];
            adaptiveCell = computePhrase(obj, 'ac');
            celebrationCell = computePhrase(obj, 'ce');
            collectiveCell = computePhrase(obj, 'cx');
          }
        } else if (r.depth === 4) {
          // lens row
          const lensObj = aimData.lenses[r.lensIndex];
          if (lensObj) {
            adaptiveCell = computePhrase(lensObj, 'ac');
            celebrationCell = computePhrase(lensObj, 'ce');
            collectiveCell = computePhrase(lensObj, 'cx');
          }
        }
        // Build row
        const tr = document.createElement('tr');
        // Attach dataset attributes for filtering
        tr.dataset.depth = displayDepth;
        tr.dataset.pillar = displayPillar;
        tr.dataset.lensTitle = (r.depth === 4 ? (r.title || '') : '');
        tr.dataset.applies = appliesText;
        if (r.depth === 4 && r.lensIndex !== undefined) {
          tr.dataset.lensIndex = r.lensIndex;
        }
        // Populate row with cells
        tr.innerHTML = `<td>${displayDepth}</td>` +
          `<td>${displayPillar}</td>` +
          `<td>${displaySub}</td>` +
          `<td>${displayMicro}</td>` +
          `<td>${r.title !== undefined ? r.title : ''}</td>` +
          `<td>${r.belief}</td>` +
          `<td>${editingEnabled ? ((typeof r.confidence === 'number' && !isNaN(r.confidence)) ? r.confidence : '') : alignCell}</td>` +
          `<td>${updatedCell}</td>` +
          `<td>${adaptiveCell}</td>` +
          `<td>${celebrationCell}</td>` +
          `<td>${collectiveCell}</td>` +
          `<td>${appliesText}</td>` +
          `<td>${todayCell}</td>` +
          `<td>${detailsCell}</td>`;
        // If editing is enabled, make certain cells editable and provide controls
        if (editingEnabled) {
          const cells = tr.children;
          // Title cell (index 4)
          const titleTd = cells[4];
          titleTd.contentEditable = true;
          titleTd.style.backgroundColor = '#fff8e1';
          titleTd.addEventListener('blur', () => {
            const newVal = titleTd.textContent.trim();
            if (r.depth === 4) {
              aimData.lenses[r.lensIndex].title = newVal;
            } else if (r.depth === 0) {
              aimData.core.title = newVal;
            } else if (r.depth === 1) {
              aimData.pillars[r.pillar].title = newVal;
            } else if (r.depth === 2) {
              aimData.subs[r.pillar][r.sub].title = newVal;
            } else if (r.depth === 3) {
              aimData.micros[r.pillar][r.sub][r.micro].title = newVal;
            }
            buildTableView();
            updateChart();
            updateLegend();
            updateLenses();
          });
          // Belief cell (index 5)
          const beliefTd = cells[5];
          beliefTd.contentEditable = true;
          beliefTd.style.backgroundColor = '#fff8e1';
          beliefTd.addEventListener('blur', () => {
            const newVal = beliefTd.textContent.trim();
            if (r.depth === 4) {
              aimData.lenses[r.lensIndex].belief = newVal;
            } else if (r.depth === 0) {
              aimData.core.belief = newVal;
            } else if (r.depth === 1) {
              aimData.pillars[r.pillar].belief = newVal;
            } else if (r.depth === 2) {
              aimData.subs[r.pillar][r.sub].belief = newVal;
            } else if (r.depth === 3) {
              aimData.micros[r.pillar][r.sub][r.micro].belief = newVal;
            }
            updateChart();
            updateLegend();
            updateLenses();
          });
          // Confidence cell (index 6)
          const confTd = cells[6];
          confTd.contentEditable = true;
          confTd.style.backgroundColor = '#fff8e1';
          confTd.addEventListener('blur', () => {
            const val = confTd.textContent.trim();
            const num = parseFloat(val);
            if (!isNaN(num) && num >= 0 && num <= 100) {
              if (r.depth === 4) {
                aimData.lenses[r.lensIndex].confidence = num;
              } else if (r.depth === 0) {
                aimData.core.confidence = num;
              } else if (r.depth === 1) {
                aimData.pillars[r.pillar].confidence = num;
              } else if (r.depth === 2) {
                aimData.subs[r.pillar][r.sub].confidence = num;
              } else if (r.depth === 3) {
                aimData.micros[r.pillar][r.sub][r.micro].confidence = num;
              }
            }
            buildTableView();
            updateChart();
            updateLegend();
            updateLenses();
          });
          // Applies cell (index 11) for lens rows: multi-select input
          const appliesTdEdit = cells[11];
          // Today cell (index 12)
          const todayTd = cells[12];
          // Details cell (index 13)
          const detailsTd = cells[13];
          // For lens rows, render applies as a multi-select dropdown
          if (r.depth === 4) {
            appliesTdEdit.innerHTML = '';
            const select = document.createElement('select');
            select.multiple = true;
            select.style.minWidth = '80px';
            select.style.fontSize = '0.85rem';
            for (let i = 1; i <= 3; i++) {
              const opt = document.createElement('option');
              opt.value = String(i);
              opt.textContent = aimData.pillarNames[i] || ('Pillar ' + i);
              if (Array.isArray(aimData.lenses[r.lensIndex].pillars) && aimData.lenses[r.lensIndex].pillars.includes(i)) {
                opt.selected = true;
              }
              select.appendChild(opt);
            }
            select.addEventListener('change', () => {
              const selected = Array.from(select.selectedOptions).map(o => parseInt(o.value));
              aimData.lenses[r.lensIndex].pillars = selected;
              r.applies = selected.map(p => aimData.pillarNames[p] || '').join(', ');
              tr.dataset.applies = r.applies;
              // update the applies cell text to reflect selection
              appliesTdEdit.textContent = r.applies;
              updateLenses();
            });
            appliesTdEdit.appendChild(select);
          }
          // Editable Today and Details cells for all rows
          todayTd.contentEditable = true;
          todayTd.style.backgroundColor = '#fff8e1';
          todayTd.addEventListener('blur', () => {
            const newVal = todayTd.textContent.trim();
            if (r.depth === 4) {
              aimData.lenses[r.lensIndex].today_state = newVal;
            } else if (r.depth === 0) {
              aimData.core.today_state = newVal;
            } else if (r.depth === 1) {
              aimData.pillars[r.pillar].today_state = newVal;
            } else if (r.depth === 2) {
              aimData.subs[r.pillar][r.sub].today_state = newVal;
            } else if (r.depth === 3) {
              aimData.micros[r.pillar][r.sub][r.micro].today_state = newVal;
            }
          });
          detailsTd.contentEditable = true;
          detailsTd.style.backgroundColor = '#fff8e1';
          detailsTd.addEventListener('blur', () => {
            const newVal = detailsTd.textContent.trim();
            if (r.depth === 4) {
              aimData.lenses[r.lensIndex].details = newVal;
            } else if (r.depth === 0) {
              aimData.core.details = newVal;
            } else if (r.depth === 1) {
              aimData.pillars[r.pillar].details = newVal;
            } else if (r.depth === 2) {
              aimData.subs[r.pillar][r.sub].details = newVal;
            } else if (r.depth === 3) {
              aimData.micros[r.pillar][r.sub][r.micro].details = newVal;
            }
          });
        }
        tableBody.appendChild(tr);
      });
      // Populate filter select options after building rows
      if (filterSelect) {
        // Add pillar options
        filterValues.forEach(name => {
          const opt = document.createElement('option');
          opt.value = 'pillar:' + name;
          opt.textContent = name;
          filterSelect.appendChild(opt);
        });
        // Add single option to show all lens rows
        if (aimData.lenses && aimData.lenses.length > 0) {
          const lensOpt = document.createElement('option');
          lensOpt.value = 'lens';
          lensOpt.textContent = 'Lenses';
          filterSelect.appendChild(lensOpt);
        }
      }
    }

    /**
     * Filters the table rows based on the search string.  Only beliefs that
     * include the search term (case‑insensitive) remain visible.
     */
    function filterTable(search) {
      // Determine which table rows to filter based on currentDataTab
      let trs;
      if (currentDataTab === 'projects') {
        trs = projectsTableBody ? projectsTableBody.querySelectorAll('tr') : [];
      } else {
        trs = tableBody.querySelectorAll('tr');
      }

    /**
     * Enter inline editing mode for a given project card.  This replaces the
     * card’s contents with editable fields and Save/Cancel buttons.  When
     * saving, the project object is updated in aimData.projects and the view
     * is refreshed.  Canceling discards changes and restores the original
     * view.
     *
     * @param {HTMLElement} card The project card DOM element to edit
     * @param {Object} project The project object to modify
     * @param {number} index Index of the project in aimData.projects
     */
    function startProjectInlineEdit(card, project, index) {
      if (!card || !project) return;
      // Prevent multiple edits on the same card
      if (card.dataset.editing === 'true') return;
      card.dataset.editing = 'true';
      // Clear card content and highlight editing state
      card.innerHTML = '';
      card.style.background = '#fffde6';
      card.style.borderColor = '#ffd27f';
      // Container for edit form
      const form = document.createElement('div');
      form.style.display = 'flex';
      form.style.flexDirection = 'column';
      form.style.gap = '6px';
      // Helper to create label/input row
      function createRow(labelText, value, multiline = false) {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '6px';
        const label = document.createElement('span');
        label.style.fontWeight = '600';
        label.style.minWidth = '100px';
        label.textContent = labelText;
        let input;
        if (multiline) {
          input = document.createElement('textarea');
          input.rows = 2;
          input.style.resize = 'vertical';
        } else {
          input = document.createElement('input');
          input.type = 'text';
        }
        input.value = value || '';
        input.style.flex = '1';
        input.style.padding = '4px';
        input.style.border = '1px solid #ccc';
        input.style.borderRadius = '4px';
        row.appendChild(label);
        row.appendChild(input);
        return { row, input };
      }
      // Name/Action field
      const nameField = createRow('Name', project.action || project.outcome || project.benefit || '');
      form.appendChild(nameField.row);
      // Type select
      const typeRow = document.createElement('div');
      typeRow.style.display = 'flex';
      typeRow.style.alignItems = 'center';
      typeRow.style.gap = '6px';
      const typeLabel = document.createElement('span');
      typeLabel.style.fontWeight = '600';
      typeLabel.style.minWidth = '100px';
      typeLabel.textContent = 'Type';
      const typeSelect = document.createElement('select');
      ['practice','sprint'].forEach(val => {
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = val.charAt(0).toUpperCase() + val.slice(1);
        typeSelect.appendChild(opt);
      });
      typeSelect.value = (project.type || '').toLowerCase() === 'sprint' ? 'sprint' : 'practice';
      typeSelect.style.flex = '1';
      typeSelect.style.padding = '4px';
      typeSelect.style.border = '1px solid #ccc';
      typeSelect.style.borderRadius = '4px';
      typeRow.appendChild(typeLabel);
      typeRow.appendChild(typeSelect);
      form.appendChild(typeRow);
      // Outcome
      const outcomeField = createRow('Outcome', project.outcome || '');
      form.appendChild(outcomeField.row);
      // Acceptance
      const acceptField = createRow('Acceptance', project.acceptance || '');
      form.appendChild(acceptField.row);
      // Reference
      const refField = createRow('Ref', project.ref || '');
      form.appendChild(refField.row);
      // Benefit
      const benefitField = createRow('Benefit', project.benefit || '');
      form.appendChild(benefitField.row);
      // Today state
      const todayField = createRow('Today', project.today_state || '');
      form.appendChild(todayField.row);
      // Details
      const detailsField = createRow('Details', project.details || '', true);
      form.appendChild(detailsField.row);
      // Practice-specific fields
      const measureField = createRow('Measure', project.measure || '');
      const startField = createRow('Start', project.start != null ? project.start : '');
      const targetField = createRow('Target', project.target != null ? project.target : '');
      const daysField = createRow('Days/week', project.days != null ? project.days : '');
      // Sprint-specific field
      const durationField = createRow('Duration', project.duration || '');
      // Functions to append fields based on type
      function appendPracticeFields() {
        form.appendChild(measureField.row);
        form.appendChild(startField.row);
        form.appendChild(targetField.row);
        form.appendChild(daysField.row);
      }
      function appendSprintFields() {
        form.appendChild(durationField.row);
      }
      // Initially append correct fields
      if (typeSelect.value === 'sprint') {
        appendSprintFields();
      } else {
        appendPracticeFields();
      }
      // Handle type changes
      typeSelect.addEventListener('change', () => {
        [measureField.row, startField.row, targetField.row, daysField.row, durationField.row].forEach(el => {
          if (el.parentElement) el.parentElement.removeChild(el);
        });
        if (typeSelect.value === 'sprint') {
          appendSprintFields();
        } else {
          appendPracticeFields();
        }
      });
      // User priority
      const userPrField = createRow('User priority', project.priority_user || '');
      form.appendChild(userPrField.row);
      // AI priority
      const aiPrField = createRow('AI priority', project.priority_ai || '');
      form.appendChild(aiPrField.row);
      // Save and Cancel buttons
      const buttonRow = document.createElement('div');
      buttonRow.style.display = 'flex';
      buttonRow.style.justifyContent = 'flex-end';
      buttonRow.style.gap = '8px';
      buttonRow.style.marginTop = '6px';
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '4px 10px';
      cancelBtn.style.fontSize = '0.85rem';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.border = '1px solid #ccc';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.background = '#f5f5f5';
      cancelBtn.addEventListener('click', () => {
        updateProjectsView();
      });
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'Save';
      saveBtn.style.padding = '4px 10px';
      saveBtn.style.fontSize = '0.85rem';
      saveBtn.style.cursor = 'pointer';
      saveBtn.style.border = '1px solid #88c6cb';
      saveBtn.style.borderRadius = '4px';
      saveBtn.style.background = '#dff1f2';
      saveBtn.addEventListener('click', () => {
        // Commit changes to the project object
        project.type = typeSelect.value;
        project.action = nameField.input.value.trim();
        project.outcome = outcomeField.input.value.trim();
        project.acceptance = acceptField.input.value.trim();
        project.ref = refField.input.value.trim();
        project.benefit = benefitField.input.value.trim();
        project.today_state = todayField.input.value.trim();
        project.details = detailsField.input.value.trim();
        project.priority_user = userPrField.input.value.trim();
        project.priority_ai = aiPrField.input.value.trim();
        if (typeSelect.value === 'sprint') {
          project.duration = durationField.input.value.trim();
          project.measure = '';
          project.start = '';
          project.target = '';
          project.days = '';
        } else {
          project.duration = '';
          project.measure = measureField.input.value.trim();
          project.start = startField.input.value.trim();
          project.target = targetField.input.value.trim();
          project.days = daysField.input.value.trim();
        }
        // Refresh projects view
        updateProjectsView();
      });
      buttonRow.appendChild(cancelBtn);
      buttonRow.appendChild(saveBtn);
      form.appendChild(buttonRow);
      card.appendChild(form);
    }
      const filterSelect = document.getElementById('tableFilterSelect');
      // Determine the selected filter.  For both beliefs and projects, allow pillar filtering.  Lens filters only apply on beliefs.
      let filterVal = 'all';
      if (filterSelect) {
        filterVal = filterSelect.value || 'all';
      }
      trs.forEach(tr => {
        // search both title and belief columns (indexes 4 and 5)
        let searchOk = true;
        if (currentDataTab === 'projects') {
          // For projects, search across all cell text
          const rowText = tr.textContent.toLowerCase();
          if (search && search.length > 0) {
            searchOk = rowText.indexOf(search) !== -1;
          }
          // Apply pillar filter for projects
          let filterOk = true;
          if (filterVal && filterVal !== 'all') {
            if (filterVal.startsWith('pillar:')) {
              const name = filterVal.slice(7);
              const rowPillar = tr.dataset.pillar || '';
              if (rowPillar !== name) {
                filterOk = false;
              }
            }
            // Lens filter is ignored on projects
          }
          tr.style.display = (searchOk && filterOk) ? '' : 'none';
        } else {
          // For AIM, search title and belief columns (indexes 4 and 5)
          const title = tr.children[4] ? tr.children[4].textContent.toLowerCase() : '';
          const belief = tr.children[5] ? tr.children[5].textContent.toLowerCase() : '';
          if (search && search.length > 0) {
            searchOk = (title.indexOf(search) !== -1 || belief.indexOf(search) !== -1);
          }
          // filter condition
          let filterOk = true;
          if (filterVal && filterVal !== 'all') {
            if (filterVal.startsWith('pillar:')) {
              const name = filterVal.slice(7);
              const rowPillar = tr.dataset.pillar || '';
              const rowApplies = tr.dataset.applies || '';
              // Show if row pillar matches or row is a lens with applies containing name
              if (rowPillar !== name) {
                // not same pillar; check if lens applies to pillar
                if (!tr.dataset.depth || tr.dataset.depth !== 'Lens' || rowApplies.indexOf(name) === -1) {
                  filterOk = false;
                }
              }
            } else if (filterVal === 'lens') {
              // Show only lens rows when 'Lenses' filter selected
              if (!tr.dataset.depth || tr.dataset.depth !== 'Lens') {
                filterOk = false;
              }
            } else if (filterVal.startsWith('lens:')) {
              // Legacy support: treat lens:Title same as lens filter
              if (!tr.dataset.depth || tr.dataset.depth !== 'Lens') {
                filterOk = false;
              }
            }
          }
          if (searchOk && filterOk) {
            tr.style.display = '';
          } else {
            tr.style.display = 'none';
          }
        }
      });
    }
  })();
  </script>
</body>
</html>
